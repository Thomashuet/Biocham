% BIOCHAM system http://contraintes.inria.fr/BIOCHAM/
% Copyright 2004-2010, INRIA, Projet Contraintes
%
% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 2
% of the License, or (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
%
% GNU prolog file biochamProlog.pl by Franï¿½ois Fages

%%% Exports Biocham model and temporal specifications to Prolog
% why ? to experiment with Inductive Logic Programming for learning rules
% how ? with Prolog clauses representing the Biocham boolean state transition system 
% states are represented by facts state(mol1,...,molN) or state(mol1,...,state(...,molN))
%        where mol is 0 if absent, 1 if present, _ if unknown
% transitions are represented by facts transition(predecessor,successor)
%        transition(state(...,0/1/_,...),state(...,0/1/_,...))

%  writes the rules, initial state and spec into an Prolog file F.

% FF modified Aug 08 to allow large states

:- include(largefunctor).

export_slp(F):-
    export_prolog(F,slp).

export_prolog(F):-
    export_prolog(F,prolog).

export_prolog(F,_):-
    \+(atom(F)),!,
    (
                have_gui
        ->
                format("[GUI] errors Filename must be an atom, or be enclosed in simple quotes.~n",[])
        ;
    write_line_col('Error'),
                write('Filename must be an atom, or be enclosed in simple quotes'),nl
        ).

export_prolog(F,prolog):-
    g_assign(prolog,prolog),
    (sub_atom(F,_,1,_,'.') -> (G=F) ; atom_concat(F,'.pl',G)),
    open(G, write, _, [alias(pl)]),
    write(pl,'% Prolog file generated by Biocham http://contraintes.inria.fr/BIOCHAM'),nl(pl),
    write(pl,'% Model of biochemical reactions represented in Prolog as a state transition system'),nl(pl),
    write(pl,'% CTL specification where reachable(X)=EF(X)checkpoint(X,Y)=!E(!X U Y) oscil(X)=EG(F X & F !X)'),nl(pl),
    write(pl,':- include(ctl).'), nl(pl),
    pl_state_repr,
    pl_initial_state,
    pl_rules,
    pl_specs,
    close(pl).

export_prolog(F,slp):-
    search_molecules,
    findall(M,molecule(M,_),LM),     % get all the molecules
    g_assign(state_list,LM),
    value_equal(LM,1,LV),
    g_assign(prolog,slp(LV)),
    (sub_atom(F,_,1,_,'.') -> (G=F) ; atom_concat(F,'.slp',G)),
    open(G, write, _, [alias(pl)]),
    write(pl,'% Stochastic Logic Program file generated by Biocham http://contraintes.inria.fr/BIOCHAM'),nl(pl),
    write(pl,'% Model of biochemical reactions represented in SLP as a state transition system'),nl(pl),
    write(pl,'% CTL specification where reachable(X)=EF(X)checkpoint(X,Y)=!E(!X U Y) oscil(X)=EG(F X & F !X)'),nl(pl),
    pl_state_repr,
    pl_initial_state,
    pl_rules,
    pl_specs,
    close(pl).

value_equal([],_,[]).
value_equal([X|L],V,[([X],V)|LV]):-
    value_equal(L,V,LV).

writePl(S):- write(pl,S),write(pl,'.'),nl(pl).
writePl(S,O):- write_term(pl,S,O),write(pl,'.'),nl(pl).

%%% write molecule names as state_repr(mol1,...,molN).

pl_state_repr :-
    nl(pl),write(pl,'%%% State variables names'),nl(pl),
    search_molecules,
    findall(A,(molecule(M,_),write_to_atom(A,M)),LM),     % get all the molecules
    g_assign(state_list,LM),
    length(LM,N),
    writePl(dimension(N)),
    large_dec(S,[state|LM]), % S=..[state|LM],
    writePl(S,[quoted(true)]),
    findall((_,B),member(B,LM),LB), % creates an association list variable_molecule
    g_assign(varmol,LB).

%%% write initial state as initial(state(...,0/1/_,...)).

pl_initial_state :-
    nl(pl),writePl('%%% Initial state'),
    writePl(':- dynamic(initial/1)'),
    findall(A,(molecule(M,_),(init_present(M)-> A=1;(init_absent(M)->A=0;true))),LM),
    large_dec(S,[state|LM]), % S=..[state|LM],
    name_singleton_vars(S), numbervars(S), % can be omitted
    writePl(initial(S)).

%%% write reactions as clauses transition(predecessor,successor)

pl_rules :-
    nl(pl),write(pl,'%%% transition(predecessor,successor)'),nl(pl),
    rule(OR,LL,LR,_,_,_,RL),
    nl(pl), write(pl,'% '),write(pl,OR),nl(pl),
    (g_read(prolog,slp(VL))
     ->
     eval(RL,VL,Z),
     write(pl,Z),write(pl,' :: ')
     ;
     true),
    list_to_atom_list(LL,AL),
    list_to_atom_list(LR,AR),
    g_read(varmol,L),
    pl_states(L,AL,AR,SL,SR),
    large_dec(S1, [state|SL]), % S1=..[state|SL],
    large_dec(S2, [state|SR]), % S2=..[state|SR],
    R=transition(S1,S2),
    name_singleton_vars(R), numbervars(R), % can be omitted
    writePl(R),
    fail.
pl_rules.

list_to_atom_list([],[]).
list_to_atom_list([(_,X)|L],[Y|R]):-
    write_to_atom(Y,X),
    list_to_atom_list(L,R).

pl_states([],_,_,[],[]).
pl_states([(V,M)|L],LL,LR,[A|SL],[B|SR]):-
    pl_states(L,LL,LR,SL,SR),
    (member(M,LL)
     ->
     A=1
     ;
     A=V),
    (member(M,LR)
     ->
     B=1
     ;
     B=V).

%%% writes the CTL specification as ctl(formula)
% where state variables are replaced by their number
pl_specs:-
    nl(pl),write(pl,'%%% CTL specification'),nl(pl),
    spec(F,_,_),
    nl(pl), write(pl,'% '),write(pl,F), nl(pl),
    pl_query(F,G), % replaces state variable names by their number
    write_canonical(pl,ctl(G)), write(pl,'.'), nl(pl),
    fail.
pl_specs.


pl_query('Ei'(A),'Ei'(B)):-
   pl_ctl(A,B).
pl_query('Ai'(A),'Ai'(B)):-
   pl_ctl(A,B).

pl_ctl(A,B):-
   functor(A,O,1),
   memberchk(O,['!','EF','EG','EX','AF','AG','AX',reachable,stable,steady,oscil]),!,
   A=..[O,C],
   pl_ctl(C,D),
   B=..[O,D].
pl_ctl(A,B):-
   functor(A,O,1),
   memberchk(O,['E','A']),!,
   A=..[O,C],
   pl_path(C,D),
   B=..[O,D].
pl_ctl(A,B):-
   functor(A,O,2),
   memberchk(O,['&','|','->','<->', checkpoint, loop]), !,
   A=..[O,C,D],
   pl_ctl(C,E),
   pl_ctl(D,F),
   B=..[O,E,F].
pl_ctl(A,I):-
   write_to_atom(B,A),
   g_read(state_list,L),
   (nth(I,L,B)
    ->
    true
    ;
    write_error(molecule_not_found(A))).

pl_path('U'(A,B),'U'(C,D)):- !,
   pl_ctl(A,C),
   pl_ctl(B,D).
pl_path('W'(A,B),'W'(C,D)):- !,
   pl_ctl(A,C),
   pl_ctl(B,D).
pl_path('F'(A),'F'(B)):- !,
   pl_ctl(A,B).
pl_path('G'(A),'G'(B)):- !,
   pl_ctl(A,B).
pl_path('X'(A),'X'(B)):- !,
   pl_ctl(A,B).



