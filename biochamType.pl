% BIOCHAM system http://contraintes.inria.fr/BIOCHAM/
% Copyright 2006-2010, INRIA, Projet Contraintes
%
% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 2
% of the License, or (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
%
% GNU prolog file biochamType.pl
% by Sylvain Soliman, Francois Fages

% Type System for Protein Functions
list_functions:- show_functions.
show_functions:-
   (
      % look for rules A =[B]=> C where C is more phosphorylated than A
      rule(A,[BB1,BB2],[CC1,CC2],_,_,_,_)
   ;
      % look for rules A+B=>A-B=>B+C where C is more phosphorylated than A
      rule(A1,[BB1,BB2],[(_,D)],_,_,_,_),
      rule(A2,[(_,D)],[CC1,CC2],_,_,_,_),
      format_to_atom(A,"~w~n   ~w",[A1,A2])
   ),
      forget_stoichiometry([BB1,BB2],[B1,B2]),
      forget_stoichiometry([CC1,CC2],C),
      (
         select(B1,C,[C2]),
         C2\=B2,
         (E=B1),
         (M1=B2),
         (M2=C2)
      ;
         select(B2,C,[C1]),
         C1\=B1,
         (E=B2),
         (M1=B1),
         (M2=C1)
      ),
      (
         more_phosphorilated_than(M2,M1)
      ->
         Type=kinase
      ;
         more_phosphorilated_than(M1,M2),
         Type=phosphatase
      ),
	(
                have_gui
        ->
                format("[GUI] list_functions ~w is a ~w for ~w in: ~w~n~n",[E,Type,M1,A])
        ;
                format("~w is a ~w for ~w in:~n   ~w~n~n",[E,Type,M1,A])
        ),
   fail.

show_functions.

% Type System for Location Topologies

:- dynamic(neighbor/2).

build_neighborhood:-
   retractall(neighbor(_,_)),
   rule(_,_,_,_,LL,LR,V),
   loc_from_stoichiometry(LL,L1),
   loc_from_stoichiometry(LR,L2),
   append(L1,L2,L3),
   loc_from_kinetics(V,LK),
   %append(L3,LK,L4),
   sort(L3),
   format_debug(7,"adding neighbors for the list: ~w~n",[L3]),
   add_neighbors(L3),
   add_single_neighbors(LK,L3),
   fail.

build_neighborhood.

loc_from_stoichiometry([],[]).
loc_from_stoichiometry([(_,loc(_,A))|L],[A|LL]):-
   !,
   loc_from_stoichiometry(L,LL).
loc_from_stoichiometry([_|L],LL):-
   loc_from_stoichiometry(L,LL).

loc_from_kinetics(['::'(_,M)],[M]):-
   !.
loc_from_kinetics([_],[]):-
   !.
loc_from_kinetics(K,[]):-
   atomic(K),!.
loc_from_kinetics(K,L):-
   K =.. [_|Args],
   loc_from_kinetics_rec(Args,L).

loc_from_kinetics_rec([],[]).
loc_from_kinetics_rec([H|T],L):-
   loc_from_kinetics(H,L1),
   loc_from_kinetics_rec(T,L2),
   append(L1,L2,L).

add_neighbors([]).
add_neighbors([_]):-
   !.
add_neighbors([A|L]):-
   !,
   add_neighbors_rec(A,L),
   add_neighbors(L).
add_neighbors([_|T]):-
   add_neighbors(T).

add_neighbors_rec(_,[]).
add_neighbors_rec(A,[B|T]):-
   !,
   (
      A \= B,
      \+(neighbor(A,B)),
      \+(neighbor(B,A))
   ->
      assertz(neighbor(A,B))
   ;
      true
   ),
   add_neighbors_rec(A,T).
add_neighbors_rec(A,[_|T]):-
   add_neighbors_rec(A,T).

add_single_neighbors([],_).
add_single_neighbors([H|T],L):-
   add_neighbors_rec(H,L),
   add_single_neighbors(T,L).

list_neighborhood:-show_neighborhood.
show_neighborhood:-
   build_neighborhood,
   neighbor(A,B),
	(
                have_gui
        ->
                format("[GUI] list_neighborhood ~w and ~w are neighbors~n",[A,B])
        ;
                format("~w and ~w are neighbors~n",[A,B])
        ),   
   fail.

show_neighborhood.

export_neighborhood_dot(F):-
   \+(atom(F)),!,
   
        (
                have_gui
        ->
                format("[GUI] errors Export neighbourhood .DOT graph: Filename must be an atom, or be enclosed in simple quotes.~n",[])
        ;
   write_line_col('Error'),
                write('Filename must be an atom, or be enclosed in simple quotes\n')
        ).

export_neighborhood_dot(F):-
	(sub_atom(F,_,_,0,'.dot') -> G=F ; atom_concat(F,'.dot',G)),
        open(G, write, _, [alias(neighbor_dot)]),
	format(neighbor_dot,"/* Model generated by BIOCHAM */~n~ndigraph \"~w\"{~n",[F]),
   write(neighbor_dot,'\tsize="7.5,11";\n'),    % A4
   write(neighbor_dot,'\tratio="fill";\n'),
   build_neighborhood,
	export_neighbors,
   write(neighbor_dot,'}\n'),
   close(neighbor_dot).

export_neighbors:-
   neighbor(A,B),
   format(neighbor_dot,"~c~w -> ~w [dir=\"none\"];~n",[9,A,B]),   % char 9 is \t
   fail.

export_neighbors.

draw_neighborhood:-
   dot_file(File),
   export_neighborhood_dot(File),
   display_dot, !.

draw_neighborhood:-
   
        (
                have_gui
        ->
                format("[GUI] errors The DOT or GV executable was not found in your PATH.~n Please install both Graphviz and gv, and check that they are in your PATH.~nThe ''export_neighborhood_dot'' command can still save your graph for future use.",[])
        ;
    write_line_col('Error'),
    write('The ''dot'' or ''gv'' executable was not found in your PATH\n'),
    write('Please install both Graphviz and gv, and check that they are in your PATH.\n'),
                write('The ''export_neighborhood_dot'' command can still save your graph for future use.\n')
        ).

% Type System for Influence Networks
% activates/inhibits(object,object,rule)

:- dynamic(activates/3).
:- dynamic(inhibits/3).

create_influence_net:-
   retractall(inhibits(_,_,_)),
   retractall(activates(_,_,_)),
   rule(R,G,D,_,_,_,_),
   substract_list(G,D,S),
   create_influences(G,S,R),
   fail.
create_influence_net.
 
% list of reactants and products with non zero right minus left coefficient
substract_list([],D,D).
substract_list([(I,A)|L],D,S):-
   (select((J,A),D,D2)
   ->
     I2 is J-I,
     (I2=0
     ->
        substract_list(L,D2,S)
     ;
        substract_list(L,D2,S2),
        S=[(I2,A)|S2])
   ;
     substract_list(L,D,S2),
     I2 is -I,
     S=[(I2,A)|S2]).

create_influences([],_,_).
create_influences([(_,A)|L],S,R):-
   create_influence(S,A,R),
   create_influences(L,S,R).

create_influence([],_,_).
create_influence([(I,B)|L],A,R):-
   ((I<0)
   ->
     (inhibits(A,B,R2)
     ->
       retractall(inhibits(A,B,R2)),
       assertz(inhibits(A,B,(R,R2)))
     ;
       assertz(inhibits(A,B,R)))
   ;
     (activates(A,B,R2)
     ->
       retractall(activates(A,B,R2)),
       assertz(activates(A,B,(R,R2)))
     ;
       assertz(activates(A,B,R)))),
   create_influence(L,A,R).


list_influences:-show_influences.
show_influences:-
   create_influence_net,
   show_activates,
   show_inhibits.

show_activates:-
   activates(A,B,R),
	(
                have_gui
        ->
                format("[GUI] list_influences \"~w\" activates \"~w\" in \"~w\" \n",[A,B,R])
        ;
               format("\"~w\" activates \"~w\" in \"~w\" \n",[A,B,R])
        ),   
   fail.

show_activates.

show_inhibits:-
   inhibits(A,B,R),
	(
                have_gui
        ->
                format("[GUI] list_influences \"~w\" inhibits \"~w\" in \"~w\"\n",[A,B,R])
        ;
                format("\"~w\" inhibits \"~w\" in \"~w\"\n",[A,B,R])
        ),  
   fail.

show_inhibits.

draw_influences:-
   dot_file(File),
   export_influences_dot(File),
   display_dot, !.

draw_influences:-
    
(
                have_gui
        ->
                format("[GUI] errors The DOT or GV executable was not found in your PATH.~n Please install both Graphviz and gv, and check that they are in your PATH.~nThe ''export_neighborhood_dot'' command can still save your graph for future use.",[])
        ;
    write_line_col('Error'),
    write('The ''dot'' or ''gv'' executable was not found in your PATH\n'),
    write('Please install both Graphviz and gv, and check that they are in your PATH.\n'),
                write('The ''export_influences_dot'' command can still save your graph for future use.\n')
        ).
   
export_influences_dot(F):-
   \+(atom(F)),!,
   
        (
                have_gui
        ->
                format("[GUI] errors Export Influences Graph: Filename must be an atom, or be enclosed in simple quotes.~n",[])
        ;
   write_line_col('Error'),
                write('Filename must be an atom, or be enclosed in simple quotes\n')
        ).

export_influences_dot(F):-
   (sub_atom(F,_,_,0,'.dot') -> G=F ; atom_concat(F,'.dot',G)),
   open(G, write, _, [alias(influence_dot)]),
   % retractall(dot_file(_)),
   % asserta(dot_file(G)),
   format(influence_dot,"/* Influence net generated by BIOCHAM */~n~ndigraph \"~w\"{~n",[F]),
   write(influence_dot,'\tsize="7.5,11";\n'),    % A4
   write(influence_dot,'\tratio="fill";\n'),
   create_influence_net,
   export_activates,
   export_inhibits,
   write(influence_dot,'}\n'),
   close(influence_dot).

export_activates:-
   activates(A,B,_),
%   format(influence_dot,"~c~w -> ~w [dir=\"none\"];~n",[9,A,B]),   % char 9 is \t
   format(
      influence_dot,
      "~c\"~w\" -> \"~w\" [color=\"green\"];~n",
      [9, A, B]
   ),
   fail.

export_activates.

export_inhibits:-
   inhibits(A,B,_),
%   format(influence_dot,"~c~w -> ~w [dir=\"none\"];~n",[9,A,B]),   % char 9 is \t
   format(
      influence_dot,
      "~c\"~w\" -> \"~w\" [arrowhead=\"tee\", color=\"red\"];~n",
      [9, A, B]
   ),
   fail.

export_inhibits.

export_influences_ginml(F):-
   \+(atom(F)),!,
   write_line_col('Error'),
   write('Filename must be an atom, or be enclosed in simple quotes\n').

export_influences_ginml(F):-
   (
      sub_atom(F,_,_,0,'.ginml')
   ->
      G=F
   ;
      atom_concat(F,'.ginml',G)
   ),
   open(G, write, _, [alias(influence_ginml)]),
   write(influence_ginml, '<?xml version="1.0" encoding="UTF-8"?>\n'),
   write(influence_ginml,
      '<!DOCTYPE gxl SYSTEM "http://gin.univ-mrs.fr/GINsim/GINML_2_1.dtd">\n'),
   write(influence_ginml, '<gxl xmlns:xlink="http://www.w3.org/1999/xlink">\n'),
   write(influence_ginml,
      '<graph id="unpacked" class="regulatory" nodeorder="'),
   search_all_molecules,
   export_nodeorder,
   write(influence_ginml, '">\n'),
   export_nodes,
   create_influence_net,
   export_activates_ginml,
   export_inhibits_ginml,
   write(influence_ginml,'</graph>\n</gxl>\n'),
   close(influence_ginml).

ginml_name(A-B, C) :-
   !,
   ginml_name(A, NA),
   ginml_name(B, NB),
   format_to_atom(C, "~w_~w", [NA, NB]).

ginml_name('~'(A,{B}), C) :-
   !,
   ginml_name(A, NA),
   ginml_list(B, NB),
   format_to_atom(C, "~w~w", [NA, NB]).

ginml_name(A, A).

ginml_list((A,B), C) :-
   !,
   ginml_list(A, NA),
   ginml_list(B, NB),
   atom_concat(NA,NB,C),
   fail.

ginml_list(A, A).

export_nodeorder:-
   molecule(A, _),
   ginml_name(A, B),
   write(influence_ginml, B),
   write(influence_ginml, ' '),
   fail.

export_nodeorder.

export_nodes :-
   molecule(A, _),
   ginml_name(A, B),
   format(
      influence_ginml,
      "<node id=\"~w\" basevalue=\"0\" maxvalue=\"1\"></node>~n",
      [B]
   ),
   fail.

export_nodes.

export_activates_ginml :-
   activates(A,B,_),
   ginml_name(A, C),
   ginml_name(B, D),
   format(
      influence_ginml,
      "<edge id=\"~w__~w_0\" from=\"~w\" to=\"~w\" minvalue=\"1\" sign=\"positive\"></edge>~n",
      [C, D, C, D]
   ),
   fail.

export_activates_ginml.

export_inhibits_ginml :-
   inhibits(A,B,_),
   ginml_name(A, C),
   ginml_name(B, D),
   format(
      influence_ginml,
      "<edge id=\"~w__~w_1\" from=\"~w\" to=\"~w\" minvalue=\"1\" sign=\"negative\"></edge>~n",
      [C, D, C, D]
   ),
   fail.

export_inhibits_ginml.

% Type System for parameter dimension
% we only consider Time since volumes are declared separately...

:- dynamic(k_unit/2).

set_dimension(P, U) :-
   UU is U+100,
   retractall(k_unit(P, _)),
   assertz(k_unit(P, UU)),
   (
      have_gui
   ->
      format("[GUI] set_dimension ~w;~w~n",[P,U])
   ;
      true
   ).

list_dimensions :-
   check_parameter_dimension.

check_parameter_dimension :-
   findall((_ - P), k_parameter(P, _), L),
   check_set_dim(L),
   apply_kinetics(K,ML),
   compile_all(K,ML,ExprList),
   find_parameter_dim_rec(ExprList, L),
   !.

check_parameter_dimension :-
   (
      have_gui
   ->
      format("[GUI] list_dimensions Error: could not satisfy time units constraints on parameter dimensions. ~n",[])
   ;
      write('Error: could not satisfy time units constraints '),
      write('on parameter dimensions\n')
   ),
   nl,
   g_read(current_dim_term, T),
   g_read(current_dim_expr, E),
   (
      have_gui
   ->
      format("[GUI] list_dimensions Failed on ~w in ~w, a kinetic expression which should be time^-1 ~n",[T, E])
   ;
      format("Failed on ~w in ~w~na kinetic expression which should be time^-1",[T, E])
   ).

check_set_dim([]).

check_set_dim([(U - P) | L]) :-
   (
      k_unit(P, U),
      !
   ;
      true
   ),
   check_set_dim(L).

find_parameter_dim_rec([], L) :-
   (
      g_read(no_dim_output, 1),
      !
   ;
      keysort(L),
      write_dimensions(L)
   ).

find_parameter_dim_rec([0 | EL], L) :-
   % no kinetics, i.e. constant species
   (
      g_read(no_dim_output, 1),
      !
   ;
      errormsg(warning, "some species are constant in this model", [])
   ),
   find_parameter_dim_rec(EL, L).

find_parameter_dim_rec([E | EL], L) :-
   format_debug(7, "Inferring for ~w with ~w~n", [E, L]),
   % all kinetics are Time^(-1)
   % but offset of 100 to stay positive
   g_assign(current_dim_expr, E), 
   find_parameter_dim(E, 99, L),
   find_parameter_dim_rec(EL, L).

find_parameter_dim(A, Dim, L) :-
   format_debug(8, "checking ~w for ~w with ~w~n", [A, Dim, L]),
   fail.

find_parameter_dim(X + Y, Dim, L) :-
   !,
   find_parameter_dim(X, Dim, L),
   find_parameter_dim(Y, Dim, L).

find_parameter_dim(X - Y, Dim, L) :- 
   !,
   find_parameter_dim(X, Dim, L),
   find_parameter_dim(Y, Dim, L).

find_parameter_dim(min(X,Y), Dim, L) :- 
   !,
   find_parameter_dim(X, Dim, L),
   find_parameter_dim(Y, Dim, L).

find_parameter_dim(max(X,Y), Dim, L) :- 
   !,
   find_parameter_dim(X, Dim, L),
   find_parameter_dim(Y, Dim, L).

find_parameter_dim(-Y, Dim, L)  :-
   !,
   find_parameter_dim(Y, Dim, L).

find_parameter_dim(abs(X), Dim, L) :-
   !,
   find_parameter_dim(X, Dim, L).


% FIXME? force dimensionless exponentiation
find_parameter_dim(X ^ Y, Dim, L) :-
   !,
   find_parameter_dim(X, D, L),
   find_parameter_dim(Y, 100, L),
   (
      (
         number(Y),
         V = Y,
         D1 = Dim,
         D2 = D
      ;
         k_parameter(Y, V),
         number(V),
         D1 = Dim,
         D2 = D
      ;
         Y = 1/Z,
         D1 = D,
         D2 = Dim,
         (
            number(Z),
            V = Z
         ;
            k_parameter(Z, V),
            number(V)
         )
      )
   ->
      (
         integer(V)
      ->
         D1 #= D2 * V - 100 * (V - 1)
      ;
         D1 #= 100,
         D2 #= 100
      )
   ).

% FIXME? correct? force Dim=0?
find_parameter_dim(log(X), Dim, L) :-
   !,
   g_assign(current_dim_term, log(X)),
   Dim #= 100,
   find_parameter_dim(X, Dim, L).

find_parameter_dim(exp(X), Dim, L) :-
   !,
   g_assign(current_dim_term, exp(X)),
   Dim #= 100,
   find_parameter_dim(X, Dim, L).

find_parameter_dim(sin(X), Dim, L) :-
   !,
   g_assign(current_dim_term, sin(X)),
   Dim #= 100,
   find_parameter_dim(X, Dim, L).

find_parameter_dim(cos(X), Dim, L) :-
   !,
   g_assign(current_dim_term, cos(X)),
   Dim #= 100,
   find_parameter_dim(X, Dim, L).

find_parameter_dim(frac(X), Dim, L) :-
   !,
   g_assign(current_dim_term, frac(X)),
   find_parameter_dim(X, Dim, L).

find_parameter_dim(N, Dim, _) :-
   number(N),
   !,
   Dim #= 100.

find_parameter_dim(random, Dim, _) :-
   !,
   Dim #= 100.

find_parameter_dim([M], Dim, _) :-
   !,
   g_assign(current_dim_term, [M]), 
   Dim #= 100.

find_parameter_dim(M, Dim, L) :- 
   k_macro(M,V),
   !,
   find_parameter_dim(V, Dim, L).

find_parameter_dim('Time', Dim, _) :-
   !,
   g_assign(current_dim_term, 'Time'), 
   Dim #= 101.

find_parameter_dim(sq_wave(P1, F1, P2, F2), Dim, _):-
   !,
   g_assign(current_dim_term, sq_wave(P1, F1, P2, F2)), 
   find_parameter_dim(P1, Dim, L),
   find_parameter_dim(P2, Dim, L).

find_parameter_dim(sq_wave(P0, F0, P1, F1, P2, F2), Dim, _):-
   !,
   g_assign(current_dim_term, sq_wave(P0, F0, P1, F1, P2, F2)), 
   find_parameter_dim(P0, Dim, L),
   find_parameter_dim(P1, Dim, L),
   find_parameter_dim(P2, Dim, L).

find_parameter_dim(X * Y, Dim, L) :-
   !,
   find_parameter_dim(X, D1, L),
   find_parameter_dim(Y, D2, L),
   g_assign(current_dim_term, X * Y), 
   Dim #= D1 + D2 - 100.

find_parameter_dim(X / Y, Dim, L) :-
   !,
   find_parameter_dim(X, D1, L),
   find_parameter_dim(Y, D2, L),
   g_assign(current_dim_term, X / Y), 
   Dim #= D1 - D2 + 100.

find_parameter_dim(if(then(_C, else(A, B))), Dim, L) :-
   !,
   find_parameter_dim(A, Dim, L),
   find_parameter_dim(B, Dim, L).

find_parameter_dim(P, Dim, L) :-
   k_parameter(P, _),
   !,
   member((D - P), L),
   Dim #= D.

write_dimensions([]).

write_dimensions([(V - P) | L]) :-
   (
      number(V)
   ->
      VV is V - 100,
      (
         VV =:= 0
      ->(
                have_gui
        ->
                format("[GUI] list_dimensions ~w is dimensionless~n", [P])
        ;
                format("~w is dimensionless~n", [P])
        )         
      ;
	(
                have_gui
        ->
                format("[GUI] list_dimensions ~w has dimension time^(~w)~n", [P, VV])
        ;
               format("~w has dimension time^(~w)~n", [P, VV])
        )         
      )
   ;
      format_debug(7, "~w has unknown dimension: ~w~n", [P, V]),
(
                have_gui
        ->
                format("[GUI] list_dimensions ~w has unknown dimension~n", [P])
        ;
               format("~w has unknown dimension~n", [P])
        )      
   ),
   write_dimensions(L).
