% BIOCHAM system http://contraintes.inria.fr/BIOCHAM/
% Copyright 2003-2010, INRIA, Projet Contraintes
%
% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 2
% of the License, or (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
%
% GNU prolog file biochamDot.pl by Sylvain Soliman
 
% Exports BIOCHAM to Graphviz's dot format

:-dynamic(dot_file/1).
:-dynamic(png_file/1).
:-dynamic(has_dot/1).
:-dynamic(has_gv/1).

export_dot(F):-
   (
      atom(F)
   ->
      export_dot(F,[])
   ;
      (
        (
                have_gui
        ->
                format("[GUI] errors Filename must be an atom, or be enclosed in simple quotes.~n",[])
        ;
                 write_line_col('Error'),
                 write('Filename must be an atom, or be enclosed in simple quotes\n')
        )
      )
   ).

export_dot(F,Options):-
	(sub_atom(F,_,_,0,'.dot') -> G=F ; atom_concat(F,'.dot',G)),
        open(G, write, _, [alias(dot)]),
	format(dot,"/* Model generated by BIOCHAM */~n~ndigraph \"~w\"{~n~c",[F,9]),
   % char 9 is tab
   g_assign(num_R,0),
   retractall(dot_path),
   (
      (member(init_up,Options),
         \+(member(state, Options)))
   ->
      dot_init
   ;
      true
   ),
   (
      member(mod_double,Options)
   ->
      g_assign(dot_mod_dash,0)
   ;
      g_assign(dot_mod_dash,1)
   ),
   (
      member(col_path,Options)
   ->
      findall(RRR,last_path(RRR),L)
   ;
      (L=[])
   ),
   (
      member(double_size,Options)
   ->
      write(dot,'size="15,11";\n')  % A3
   ;
      write(dot,'size="7.5,11";\n') % A4
   ),
   write(dot,'\tratio="fill";\n'),
   (
      member(state, Options)
   ->
      dot_state
   ;
      dot_rules(L)
   ),
	close(dot).


draw_reactions:-
   dot.

dot:-
   dot_file(File),
   export_dot(File),
   display_dot,
   !.

display_dot :-
   (
      has_dot(Dot)
   ;
      (
         find_in_path(dot,Dot)
      ->
         assertz(has_dot(Dot))
      ;
        
        (
                have_gui
        ->
                format("[GUI] errors DOT is not found in PATH.~n",[])
        ;
                write_error('dot not found in PATH')
        ),
         fail
      )
   ),!,
   (
      have_gui
   ->
      dot_file(File),
      call_dot_for_png(Dot, File)
   ;
      png
   ->
      dot_file(File), 
      call_dot_for_fresh_png(Dot, File)
   ;
      (
         has_gv(Gv)
      ;
         (
            find_in_path(gv,Gv)
         ->
            assertz(has_gv(Gv))
         ;
           
        (
                have_gui
        ->
                format("[GUI] errors GV is not found in PATH.~n",[])
        ;
                write_error('gv not found in PATH')
        ),
            fail
         )
      ),!,
      dot_file(File),
      format_to_atom(Cmd,"~w -Tps '~w' | ~w -",[Dot,File,Gv]),
      system(Cmd,_)
   ).

display_dot :-
   print('there'),
   (
      has_dot(Dot)
   ;
      (
         find_in_path(dot,Dot)
      ->
         assertz(has_dot(Dot))
      ;
        
        (
                have_gui
        ->
                format("[GUI] errors DOT is not found in PATH.~n",[])
        ;
                write_error('dot not found in PATH')
        ),
         fail
      )
   ),!,
   (
      have_gui
   ->
      dot_file(File),
      call_dot_for_png(Dot, File)
   ;
      png
   ->
      print('here'),
      nl,
      dot_file(File), 
      call_dot_for_fresh_png(Dot, File)
   ;
      (
         has_gv(Gv)
      ;
         (
            find_in_path(gv,Gv)
         ->
            assertz(has_gv(Gv))
         ;
           
        (
                have_gui
        ->
                format("[GUI] errors GV is not found in PATH.~n",[])
        ;
                write_error('gv not found in PATH')
        ),
            fail
         )
      ),!,
      dot_file(File),
      format_to_atom(Cmd,"~w -Tps '~w' | ~w -",[Dot,File,Gv]),
      system(Cmd,_)
   ).

call_dot_for_png(Dot, File) :-
   png_file(Png),
   % Use spawn and not system because system calls a SHELL (not good for
   % cygwin compiled cygwin-free windows version)
   % if DOT is found in path, we can call 'dot' regardless of the OS
   spawn('dot', ['-Tpng', '-o', Png, File], Status),
   format_debug(5, "Cmd: ~w ~w ~w ~w ~w~nStatus: ~w~n",
      [Dot, '-Tpng', '-o', Png, File, Status]),
      format("[GUI] dot ~w~n",[Png]).

call_dotNetwork_for_png(Dot, File) :-
    png_file(Png),
    % Use spawn and not system because system calls a SHELL (not good for
    % cygwin compiled cygwin-free windows version)
	% if DOT is found in path, we can call 'dot' regardless of the OS
    spawn('dot', ['-Tpng', '-o', Png, File], Status),
    format_debug(5, "Cmd: ~w ~w ~w ~w ~w~nStatus: ~w~n",
      [Dot, '-Tpng', '-o', Png, File, Status]),
    format("[GUI] dotNetwork ~w~n",[Png]).

call_dot_for_fresh_png(Dot, File) :-
    fresh_png_file(Png),
    % Use spawn and not system because system calls a SHELL (not good for
    % cygwin compiled cygwin-free windows version)
	% if DOT is found in path, we can call 'dot' regardless of the OS
    spawn('dot', ['-Tpng', '-o', Png, File], Status),
    format_debug(5, "Cmd: ~w ~w ~w ~w ~w~nStatus: ~w~n",
      [Dot, '-Tpng', '-o', Png, File, Status]),
    output_png.

dot_quit_hook:-
   png_file(Png),
   unlink(Png),
   dot_file(Dot),
   unlink(Dot).

dot_init_hook(Tmp, A):-
   format_to_atom(B,'~w.dot_~w',[Tmp, A]),
   atom_concat(B,'.tmp.dot',Dot),
   assertz(dot_file(Dot)),
   atom_concat(B,'.tmp.png',Png),
   assertz(png_file(Png)).

dot_init :-
   format(dot,"~c{ rank=source; ",[9]),
   dot_init2.

dot_init2 :-
   init_present(M),
   format(dot,"\"~w\"; ",[M]),
   fail.

dot_init2 :-
   format(dot,"}~n",[]).

dot_rules(L) :-
   rule(_,L1,L2,_,_,_,_),
	forget_stoichiometry(L1,LL),
	forget_stoichiometry(L2,LR),
   g_read(num_R,Old),
	New is Old +1,
	g_assign(num_R,New),
   format(dot,"~crule_~w [shape = box",[9,New]),
   (
      memberchk(New,L)
   ->
      ((Opt1=', color = red'),
       (Opt2=' [color = red]'))
   ;
      ((Opt1=''),
       (Opt2=''))
   ),
   write(dot,'];\n'),
   g_read(dot_mod_dash,EB),
   (
      (EB > 0)
   ->
      (dot_intersect(LL,LR,I,LLL,LLR),
       dot_catalize(I,New,Opt1))
   ;
      (LLL = LL,
       LLR = LR)
   ),
   dot_input(LLL,New,Opt2),
   dot_output(LLR,New,Opt2),
   fail.

dot_rules(_) :-
   write(dot,'}'),nl(dot).

dot_input([],_,_).

dot_input([H|T],N,O) :-
   format(dot,"~c\"~w\" -> rule_~w~w;~n",[9,H,N,O]),
   dot_input(T,N,O).

dot_output([],_,_).

dot_output([H|T],N,O) :-
   format(dot,"~crule_~w -> \"~w\"~w;~n",[9,N,H,O]),
   dot_output(T,N,O).

dot_catalize([],_,_).

dot_catalize([H|T],N,O) :-
   format(dot,"~c\"~w\" -> rule_~w [arrowhead=\"odot\",style=dashed~w];~n",[9,H,N,O]),
   dot_catalize(T,N,O).

% dot_intersect(List1,List2,List1 \cup List2, List1\List2, List2\List1)

dot_intersect([],L,[],[],L).
dot_intersect([H|T],L,[H|I],T2,L2) :-
   select(H,L,L3),!,
   dot_intersect(T,L3,I,T2,L2).
dot_intersect([H|T],L,I,[H|T2],L2) :-
   dot_intersect(T,L,I,T2,L2).

% state graph

dot_state :-
   nusmv_search_molecules, 
   findall(M,molecule(M,_),L),
   dot_state_rules(L).

dot_state_rules(L):-
   g_assign(num_R,0),
   rule(_,L1,L2,_,_,_,_),
      forget_stoichiometry(L1,LL),
      forget_stoichiometry(L2,LR),
      g_read(num_R,Old),
      New is Old+1,
      g_assign(num_R,New),
      get_state(L,LL,LR,SL,SR),
         format(dot,"~c\"~w\" -> \"~w\" [label = \"~w\"];~n",[9,SL,SR,New]),
         fail.

dot_state_rules(_):-
   write(dot,'}\n').

get_state(L,LL,LR,SL,SR):-
   delete_rec(L,LL,Unknown),
   sublist(Present,Unknown),
   append(LL,Present,AllPresent),
   sort(AllPresent),
   write_to_atom(SL,AllPresent),
   append(LR,Present,Present2),
   delete_rec(LL,LR,ConsumedOrNot),
   sublist(NotConsumed,ConsumedOrNot),
   append(Present2,NotConsumed,AllPresent2),
   sort(AllPresent2,AP2),
   write_to_atom(SR,AP2).

delete_rec(L,[],L).
delete_rec(L1,[H|T],L2):-
   delete(L1,H,L3),
   delete_rec(L3,T,L2).
