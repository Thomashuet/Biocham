% BIOCHAM system http://contraintes.inria.fr/BIOCHAM/
% Copyright 2003-2006, INRIA, Projet Contraintes
%
% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 2
% of the License, or (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
%
% GNU prolog file regexp.pl
% by Daniel de Rauglaudre

% This file has been generated by program: do not edit!
regexp_make(CCL1, RE) :-
	g_read(regexp_initialized, Initialized),
	regexp_init(Initialized),
	codes_tokens(0, CCL1, TL1),
	llist_nil(TL2),
	parsing_call(regexp_parser(RE, TL1, TL2), 0, call).
:- dynamic(regexp_parser / 3).
:- dynamic(regexp_parser / 4).
regexp_init(true).
regexp_init(I) :-
	I \= true,
	g_assign(regexp_initialized, true),
	parsing_create_entry(regexp_parser, call),
	reg_op(100, [x(X), f('|'), y(Y)], re_big_or(X, Y)),
	reg_op(50, [x(X), y(Y)], re_seq(X, Y)),
	reg_op(30, [x(RE), f(*)], re_rep0(RE)),
	reg_op(30, [x(RE), f(+)], re_rep1(RE)),
	reg_op(30, [x(RE), f((?))], re_opt(RE)),
	reg_op(1, [f('('), z(RE), f(')')], re_sel(RE)),
	reg_op(1, [f('('), f((?)), f(:), z(RE), f(')')], RE),
	reg_op(1, [f('('), f((?)), f(!), z(RE), f(')')], re_neg_lookhd(RE)),
	reg_op(1, [f('('), f((?)), f(=), z(RE), f(')')], re_pos_lookhd(RE)),
	reg_op(1, [f('['), p(regexp_bracket_expr, REL), f(']')], re_or(REL)),
	reg_op(1, [f('['), f(^), p(regexp_bracket_expr, REL), f(']')], re_nor(REL)),
	reg_op(1, [f('.')], re_any),
	reg_op(1, [t(CC)], call_act(act_char(CC))),
	reg_op(1, [f(@), t(CC)], re_char(CC)), !.
reg_op(Lev, Rule, Act) :-
	parsing_rule_asserta(regexp_parser, regexp_token, Lev, Rule, Act, call).
act_char(CC, re_char(CC), _, _) :-
	CC \= 64,
	CC \= 40,
	CC \= 41,
	CC \= 124,
	CC \= 91,
	CC \= 46 .
regexp_bracket_expr([re_interv(CC1, CC2)|REL], L1, L5) :-
	regexp_bracket_expr1(re_char(CC1), L1, L2),
	llist_hd_tl(L2, tok(_, some(45)), L3),
	regexp_bracket_expr1(re_char(CC2), L3, L4),
	regexp_bracket_expr(REL, L4, L5).
regexp_bracket_expr([RE|REL], L1, L3) :-
	regexp_bracket_expr1(RE, L1, L2),
	regexp_bracket_expr(REL, L2, L3).
regexp_bracket_expr([]) -->
	[].
regexp_bracket_expr1(re_char(CC), L1, L2) :-
	llist_hd2_tl(L1, tok(_, some(64)), tok(_, some(CC)), L2).
regexp_bracket_expr1(re_char(CC), L1, L2) :-
	llist_hd_tl(L1, tok(_, some(CC)), L2),
	CC \= 93,
	CC \= 45,
	CC \= 64 .
codes_tokens(_, [], TL) :-
	llist_nil(TL).
codes_tokens(BP, CCL1, TTL) :-
	llist_hd_tl(TTL, tok(ta_loc(BP, EP), some(CC)), TL),
	EP is BP + 1,
	CCL1 = [CC|CCL2],
	codes_tokens(EP, CCL2, TL).
regexp_token(some(CC), CCL1, CCL2) :-
	llist_hd_tl(CCL1, chr(_, CC), CCL2).
