% BIOCHAM system http://contraintes.inria.fr/BIOCHAM/
% Copyright 2003-2006, INRIA, Projet Contraintes
%
% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 2
% of the License, or (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
%
% GNU prolog file lexing.pl
% by Daniel de Rauglaudre

% This file has been generated by program: do not edit!
lexing_create(Synt, Call) :-
	mod_atom_concat(Synt, '_next_token', NextToken),
	mod_atom_concat(Synt, '_skip_spaces', SkipSpaces),
	mod_atom_concat(Synt, '_token', Token),
	equal_dot_dot(SkipSpacesArg, [SkipSpaces, CL1, CL2]),
	equal_dot_dot(TokenArg, [Token, T, CL2, CL3]),
	equal_dot_dot(NextTokenArg, [NextToken, tok(Attr, T), CL1, CL3]),
	(equal_dot_dot(CallArgs0, [Call, assertz((NextTokenArg :- SkipSpacesArg, lexing_char_list_pos(CL2, -1, BP), TokenArg, lexing_char_list_pos(CL3, BP, EP), parsing_token_attr_loc(Attr, BP, EP)))]), call(CallArgs0)),
	CL1 = CL2,
	(equal_dot_dot(CallArgs1, [Call, assertz(SkipSpacesArg)]), call(CallArgs1)),
	equal_dot_dot(TokenArg2, [Token, none, CL3, CL4]),
	equal_dot_dot(CallArgs2, [Call, assertz((TokenArg2 :- llist_hd_tl(CL3, eof(_), CL4)))]),
	call(CallArgs2).
lexing_add_spaces(Synt, ChrL, Call) :-
	reverse(ChrL, RChrL),
	lexer_space_chr(Synt, RChrL, Call).
lexing_add_comment(Synt, BChrL, EChrL, Opts, Call) :-
	mod_atom_concat(Synt, '_skip_spaces', SkipSpaces),
	equal_dot_dot(SkipSpacesArg1, [SkipSpaces, L1, L5]),
	lexer_parse_char_list(BChrL, L1, L3, Goal1),
	(member(rec, Opts) -> RecOpt = some(BChrL); RecOpt = none),
	(member(eof, Opts) -> EofOpt = true; EofOpt = false),
	Goal2 = llist_hd_tl(L1, chr(IniP, _), _),
	GoalSkipTo = lexer_skip_to(EChrL, RecOpt - EofOpt, IniP, L3, L4),
	equal_dot_dot(SkipSpacesArg2, [SkipSpaces, L4, L5]),
	Goal = (Goal1, Goal2, GoalSkipTo, SkipSpacesArg2),
	Clause = (SkipSpacesArg1 :- Goal),
	equal_dot_dot(CallArgs0, [Call, asserta(Clause)]),
	call(CallArgs0).
lexing_add_token(Synt, RegExp, SemAct, Call) :-
	regexp_make(RegExp, RE),
	mod_atom_concat(Synt, '_token', Lexer),
	regexp_goal(Lexer, RE, SemAct, Call).
lexing_add_token(_, RegExp, _, _) :-
	atom_codes(Txt, RegExp),
	format_to_atom(Err, 'error in regexp "~w"', [Txt]),
	throw(lexerr(Err)).
stream_char_list(S, CL) :-
	char_list(0, S, CL).
char_list_token_list(NextToken, CL, TTL) :-
	llist_hd_tl(TTL, T, TL),
	(equal_dot_dot(NextTokenArgs0, [NextToken, T, CL, CL1]), call(NextTokenArgs0)),
	char_list_token_list(NextToken, CL1, TL).
char_list_token_list(_, CL, TL) :-
	llist_nil(CL),
	llist_nil(TL).
char_list_token_list(_, CL, TL) :-
	llist_hd_tl(CL, chr(BP, _), _),
	llist_nil(TL),
	EP is BP + 1,
	Err = 'remaining characters from this one are not lexed',
	throw(exc_loc(BP, EP, lexerr(Err))).
char_list(P, S, CL) :-
	at_end_of_stream(S),
	llist_single(CL, eof(P)).
char_list(P, S, CL1) :-
	llist_hd_tl(CL1, chr(P, C), CL2),
	get_code(S, C),
	C \= -1,
	NP is P + 1,
	char_list(NP, S, CL2).
lexer_space_chr(Synt, [Chr|ChrL], Call) :-
	lexer_space_one_chr(Synt, Chr, Call),
	lexer_space_chr(Synt, ChrL, Call).
lexer_space_chr(_, [], _).
lexer_space_one_chr(Synt, Chr, Call) :-
	mod_atom_concat(Synt, '_skip_spaces', SkipSpaces),
	equal_dot_dot(SkipSpacesArg, [SkipSpaces, L1, L3]),
	Goal1 = llist_hd_tl(L1, chr(_, Chr), L2),
	equal_dot_dot(Goal2, [SkipSpaces, L2, L3]),
	Clause = (SkipSpacesArg :- Goal1, Goal2),
	equal_dot_dot(CallArgs0, [Call, asserta(Clause)]),
	call(CallArgs0).
lexer_skip_to([Chr|ChrL], _, _, L1, L3) :-
	llist_hd_tl(L1, chr(_, Chr), L2),
	lexer_skip_to2(ChrL, L2, L3).
lexer_skip_to(EChrL, Opts, IniP, L1, L5) :-
	Opts = some([Chr|ChrL]) - _,
	llist_hd_tl(L1, chr(_, Chr), L2),
	lexer_skip_to2(ChrL, L2, L3),
	lexer_skip_to(EChrL, Opts, IniP, L3, L4),
	lexer_skip_to(EChrL, Opts, IniP, L4, L5).
lexer_skip_to(_, Opts, _, L1, L2) :-
	Opts = _ - true,
	llist_hd_tl(L1, eof(_), _),
	L2 = L1.
lexer_skip_to(ChrL, Opts, IniP, L1, L3) :-
	llist_hd_tl(L1, chr(_, _), L2),
	lexer_skip_to(ChrL, Opts, IniP, L2, L3).
lexer_skip_to(_, _, IniP, L1, L2) :-
	llist_hd_tl(L1, eof(P), L2),
	throw(exc_loc(IniP, P, lexerr('comment not terminated'))).
lexer_skip_to2([], L, L).
lexer_skip_to2([Chr|ChrL], L1, L3) :-
	llist_hd_tl(L1, chr(_, Chr), L2),
	lexer_skip_to2(ChrL, L2, L3).
lexing_char_list_pos(CL, _, P) :-
	llist_pos(CL, some(P)).
lexing_char_list_pos(CL, _, P) :-
	llist_hd_tl(CL, chr(P, _), _).
lexing_char_list_pos(CL, _, P) :-
	llist_hd_tl(CL, eof(P), _).
lexing_char_list_pos(CL, P, P) :-
	llist_nil(CL).
lexer_interv(AC, BC, CC, L1, L2) :-
	llist_hd_tl(L1, chr(_, CC), L2),
	CC >= AC,
	CC =< BC.
zero_or_several_chars_among(PC, [C|CL]) -->
	char_among(PC, C),
	zero_or_several_chars_among(PC, CL).
zero_or_several_chars_among(_, []) -->
	[].
zero_or_several_chars_not_among(PC, [C|CL]) -->
	char_not_among(PC, C),
	zero_or_several_chars_not_among(PC, CL).
zero_or_several_chars_not_among(_, []) -->
	[].
one_or_several_chars_among(PC, [C|CL]) -->
	char_among(PC, C),
	zero_or_several_chars_among(PC, CL).
one_or_several_chars_not_among(PC, [C|CL]) -->
	char_not_among(PC, C),
	one_or_several_chars_not_among(PC, CL).
char_among(IL, C, CL1, CL2) :-
	llist_hd_tl(CL1, chr(_, C), CL2),
	code_among(IL, C).
char_not_among(IL, C, CL1, CL2) :-
	llist_hd_tl(CL1, chr(_, C), CL2),
	code_not_among(IL, C).
code_among([code_interv(AC, BC)|_], CC) :-
	CC >= AC,
	CC =< BC.
code_among([code(CC)|_], CC).
code_among([_|IL], CC) :-
	code_among(IL, CC).
code_not_among([code_interv(AC, _)|IL], CC) :-
	CC < AC,
	code_not_among(IL, CC).
code_not_among([code_interv(_, BC)|IL], CC) :-
	CC > BC,
	code_not_among(IL, CC).
code_not_among([code(AC)|IL], CC) :-
	CC \= AC,
	code_not_among(IL, CC).
code_not_among([], _).
regexp_goal(Lexer, RE, X - SemAct, Call) :- !,
	equal_dot_dot(LexerArg, [Lexer, some(R), L1, L3]),
	regexp_goal_var_list(Lexer, SemAct, RE, GoalVarList, L1, L2, Call),
	goalvarlist_goallist(GoalVarList, GoalList1),
	goalvarlist_charlist(GoalVarList, CharList, ExtraGoalList),
	append(GoalList1, ExtraGoalList, GoalList2),
	assign_atom_codes_or_atom(T, CharList, ExtraGoalList1),
	append(GoalList2, ExtraGoalList1, GoalList),
	copy_term(X - SemAct, T - R),
	L2 = L3,
	list_fold_right(Goal, GoalList, true),
	equal_dot_dot(CallArgs0, [Call, asserta((LexerArg :- Goal))]),
	call(CallArgs0).
regexp_goal(Lexer, RE, SemAct, Call) :-
	equal_dot_dot(LexerArg, [Lexer, some(R), L1, L3]),
	regexp_goal_var_list(Lexer, SemAct, RE, GoalVarList, L1, L2, Call),
	goalvarlist_goallist(GoalVarList, GoalList1),
	goalvarlist_charlist(GoalVarList, CharList, ExtraGoalList),
	append(GoalList1, ExtraGoalList, GoalList2),
	assign_atom_codes_or_atom(T, CharList, ExtraGoalList1),
	append(GoalList2, ExtraGoalList1, GoalList),
	equal_dot_dot(SemAct, [Pred|Args]),
	append(Args, [T, R, L2, L3], NArgs),
	equal_dot_dot(CallPred1, [Pred|NArgs]),
	eq_frz(CallPred, T, R, CallPred1),
	list_fold_right(Goal, GoalList, CallPred),
	equal_dot_dot(CallArgs0, [Call, asserta((LexerArg :- Goal))]),
	call(CallArgs0).
assign_atom_codes_or_atom(T, CharList, []) :-
	byte_list(CharList),
	atom_codes(T, CharList).
assign_atom_codes_or_atom(T, CharList, [Goal]) :-
	nonvar(CharList),
	CharList = [X|_],
	eq_frz(Goal, T, X, atom_codes(T, CharList)).
assign_atom_codes_or_atom(T, CharList, [Goal]) :-
	eq_frz(Goal, T, CharList, atom_codes(T, CharList)).
byte_list(CL) :-
	nonvar(CL),
	CL = [].
byte_list(CL) :-
	nonvar(CL),
	CL = [C1|CL1],
	nonvar(C1),
	integer(C1),
	byte_list(CL1).
regexp_goal_var_list(Lexer, SemAct, RE, GoalVarList, L1, L2, Call) :-
	RE = re_big_or(_, _),
	big_or_list(RE, REL),
	regexp_index(Index),
	regexp_big_or_list(Lexer, Index, SemAct, REL, Call),
	equal_dot_dot(G1, [Lexer, Index, CL, L1, L2]),
	eq_frz(G, CL, L1, G1),
	GoalVarList = [no_sel(G, char_list(CL))].
regexp_goal_var_list(Lexer, SemAct, re_rep0(RE), GVL, L1, L2, Call) :-
	regexp_goal_var_list_repeat0(Lexer, SemAct, RE, Goal, CL, L1, L2, Call),
	GVL = [no_sel(Goal, char_list(CL))].
regexp_goal_var_list(Lexer, SemAct, re_rep1(RE), GVL, L1, L2, Call) :-
	regexp_goal_var_list_repeat1(Lexer, SemAct, RE, Goal, CL, L1, L2, Chk, Call),
	GVL = [no_sel(Goal, char_list(CL))|Chk].
regexp_goal_var_list(Lexer, SemAct, re_opt(RE), GVL, L1, L2, Call) :-
	regexp_goal_var_list_opt(Lexer, SemAct, RE, Goal, CL, L1, L2, Call),
	GVL = [no_sel(Goal, char_list(CL))].
regexp_goal_var_list(Lexer, SemAct, RE, GoalVarList, L1, L2, Call) :-
	RE = re_seq(_, _),
	sequence_list(RE, REL),
	regexp_seq_list(Lexer, SemAct, REL, GoalVarList, L1, L2, Call).
regexp_goal_var_list(Lexer, SemAct, re_sel(RE), GoalVarList, L1, L2, Call) :-
	regexp_goal_var_list(Lexer, SemAct, RE, GoalVarList1, L1, L2, Call),
	GoalVarList = [selected(GoalVarList1)].
regexp_goal_var_list(Lexer, SemAct, re_pos_lookhd(RE), GoalVarList, L1, L1, Call) :-
	regexp_goal_var_list(Lexer, SemAct, RE, GoalVarList1, L1, _, Call),
	ignore_return(GoalVarList1, GoalVarList).
regexp_goal_var_list(Lexer, SemAct, re_neg_lookhd(RE), GoalVarList, L1, L1, Call) :-
	regexp_index(Index),
	make_neg_lookhd(Lexer, SemAct, RE, Index, Call),
	equal_dot_dot(G, [Lexer, Index, _, L1, _]),
	GoalVarList = [no_sel(\+(G), no_char)].
regexp_goal_var_list(_, _, re_or(REL), [no_sel(Goal, char(C))], L1, L2, _) :-
	or_list_char_list(REL, CCL),
	eq_frz(Goal, C, L1, char_among(CCL, C, L1, L2)).
regexp_goal_var_list(_, _, re_nor(REL), [no_sel(Goal, char(C))], L1, L2, _) :-
	or_list_char_list(REL, CCL),
	goal_not_among(CCL, C, Goal, L1, L2).
regexp_goal_var_list(_, _, re_char(C), [no_sel(Goal, char(C))], L1, L2, _) :-
	Goal1 = llist_hd_tl(L1, chr(_, C), L2),
	eq_frz(Goal, L1, L2, Goal1).
regexp_goal_var_list(_, _, re_any, [no_sel(Goal, char(C))], L1, L2, _) :-
	Goal = llist_hd_tl(L1, chr(_, C), L2).
make_neg_lookhd(Lexer, SemAct, RE, Index, Call) :-
	equal_dot_dot(TokenArg, [Lexer, Index, _, L1, _]),
	regexp_goal_var_list(Lexer, SemAct, RE, GoalVarList, L1, _, Call),
	goalvarlist_goallist(GoalVarList, GoalList),
	list_fold_right(Goal, GoalList, true),
	equal_dot_dot(CallArgs0, [Call, asserta((TokenArg :- Goal))]),
	call(CallArgs0).
goalvarlist_goallist([no_sel(X = Y, _)|GVL], GL) :-
	var(X),
	X = Y,
	goalvarlist_goallist(GVL, GL).
goalvarlist_goallist([no_sel(G, _)|GVL], [G|GL]) :-
	goalvarlist_goallist(GVL, GL).
goalvarlist_goallist([selected(GVL1)|GVL2], GL) :-
	goalvarlist_goallist(GVL1, GL1),
	goalvarlist_goallist(GVL2, GL2),
	append(GL1, GL2, GL).
goalvarlist_goallist([], []).
goalvarlist_charlist(GoalVarList, CharList, ExtraGoalList) :-
	sel_goalvarlist_charlist(GoalVarList, CharList, ExtraGoalList).
goalvarlist_charlist(GoalVarList, CharList, ExtraGoalList) :-
	all_goalvarlist_charlist(GoalVarList, CharList, ExtraGoalList).
sel_goalvarlist_charlist([no_sel(_, _)|GVL], CL, EGL) :-
	sel_goalvarlist_charlist(GVL, CL, EGL).
sel_goalvarlist_charlist([selected(GVL)|_], CL, EGL) :-
	all_goalvarlist_charlist(GVL, CL, EGL).
all_goalvarlist_charlist([no_sel(_, no_char)|GVL], CL, EGL) :-
	all_goalvarlist_charlist(GVL, CL, EGL).
all_goalvarlist_charlist([no_sel(_, char(C))|GVL], [C|CL], EGL) :-
	all_goalvarlist_charlist(GVL, CL, EGL).
all_goalvarlist_charlist([no_sel(_, char_list(CL1))|GVL], CL, EGL) :-
	all_goalvarlist_charlist(GVL, CL2, EGL2),
	(CL2 == [] -> CL = CL1, EGL = EGL2; append(EGL2, [append(CL1, CL2, CL)], EGL)).
all_goalvarlist_charlist([selected(GVL1)|GVL], CL, EGL) :-
	all_goalvarlist_charlist(GVL1, CL1, EGL1),
	all_goalvarlist_charlist(GVL, CL2, EGL2),
	append(EGL1, EGL2, EGL3),
	append(EGL3, [append(CL1, CL2, CL)], EGL).
all_goalvarlist_charlist([], [], []).
regexp_big_or_list(Lexer, Index, SemAct, [RE|REL], Call) :-
	regexp_big_or_list(Lexer, Index, SemAct, REL, Call),
	equal_dot_dot(TokenArg, [Lexer, Index, R, L1, L2]),
	regexp_goal_var_list(Lexer, SemAct, RE, GoalVarList, L1, L2, Call),
	goalvarlist_goallist(GoalVarList, GoalList1),
	goalvarlist_charlist(GoalVarList, R, ExtraGoalList),
	append(GoalList1, ExtraGoalList, GoalList),
	list_fold_right(Goal, GoalList, true),
	equal_dot_dot(CallArgs0, [Call, asserta((TokenArg :- Goal))]),
	call(CallArgs0).
regexp_big_or_list(_, _, _, [], _).
regexp_goal_var_list_repeat0(Lexer, SemAct, RE, Goal, CL, L1, L2, Call) :-
	RE = re_big_or(_, _),
	big_or_list(RE, REL),
	regexp_index(Index),
	equal_dot_dot(Clause, [Lexer, Index, [], L, L]),
	(equal_dot_dot(CallArgs0, [Call, asserta(Clause)]), call(CallArgs0)),
	regexp_list_repeator(Lexer, Index, SemAct, REL, Call),
	equal_dot_dot(Goal1, [Lexer, Index, CL, L1, L2]),
	eq_frz(Goal, CL, L1, Goal1).
regexp_goal_var_list_repeat0(_, _, re_or(REL), Goal, CL, L1, L2, _) :-
	or_list_char_list(REL, CCL),
	eq_frz(Goal, CL, L1, zero_or_several_chars_among(CCL, CL, L1, L2)).
regexp_goal_var_list_repeat0(_, _, re_nor(REL), Goal, CL, L1, L2, _) :-
	or_list_char_list(REL, CCL),
	Goal = zero_or_several_chars_not_among(CCL, CL, L1, L2).
regexp_goal_var_list_repeat0(_, _, re_char(C), Goal, CL, L1, L2, _) :-
	eq_frz(Goal, CL, L1, zero_or_several_chars_among([code(C)], CL, L1, L2)).
regexp_goal_var_list_repeat0(Lexer, SemAct, RE, Goal, CL, L1, L2, Call) :-
	regexp_index(Index),
	equal_dot_dot(Clause, [Lexer, Index, [], L, L]),
	(equal_dot_dot(CallArgs0, [Call, asserta(Clause)]), call(CallArgs0)),
	regexp_list_repeator(Lexer, Index, SemAct, [RE], Call),
	equal_dot_dot(Goal, [Lexer, Index, CL, L1, L2]).
regexp_goal_var_list_repeat1(Lexer, SemAct, RE, Goal, CL, L1, L2, Chk, Call) :-
	RE = re_big_or(_, _),
	big_or_list(RE, REL),
	regexp_index(Index),
	equal_dot_dot(Clause, [Lexer, Index, [], L, L]),
	(equal_dot_dot(CallArgs0, [Call, asserta(Clause)]), call(CallArgs0)),
	regexp_list_repeator(Lexer, Index, SemAct, REL, Call),
	equal_dot_dot(Goal, [Lexer, Index, CL, L1, L2]),
	Chk = [no_sel(CL \= [], no_char)].
regexp_goal_var_list_repeat1(_, _, re_or(REL), Goal, CL, L1, L2, [], _) :-
	or_list_char_list(REL, CCL),
	eq_frz(Goal, CL, L1, one_or_several_chars_among(CCL, CL, L1, L2)).
regexp_goal_var_list_repeat1(_, _, re_nor(REL), Goal, CL, L1, L2, [], _) :-
	or_list_char_list(REL, CCL),
	Goal = one_or_several_chars_not_among(CCL, CL, L1, L2).
regexp_goal_var_list_repeat1(_, _, re_char(C), Goal, CL, L1, L2, [], _) :-
	eq_frz(Goal, CL, L1, one_or_several_chars_among([code(C)], CL, L1, L2)).
regexp_goal_var_list_repeat1(Lexer, SemAct, RE, Goal, CL, L1, L2, Chk, Call) :-
	regexp_index(Index),
	equal_dot_dot(Clause, [Lexer, Index, [], L, L]),
	(equal_dot_dot(CallArgs0, [Call, asserta(Clause)]), call(CallArgs0)),
	regexp_list_repeator(Lexer, Index, SemAct, [RE], Call),
	equal_dot_dot(Goal, [Lexer, Index, CL, L1, L2]),
	Chk = [no_sel(CL \= [], no_char)].
regexp_goal_var_list_opt(Lexer, SemAct, RE, Goal, CL, L1, L2, Call) :-
	regexp_index(Index),
	equal_dot_dot(Clause, [Lexer, Index, [], L, L]),
	(equal_dot_dot(CallArgs0, [Call, asserta(Clause)]), call(CallArgs0)),
	regexp_list_option(Lexer, Index, SemAct, [RE], Call),
	equal_dot_dot(Goal, [Lexer, Index, CL, L1, L2]).
regexp_seq_list(Lexer, SemAct, [RE|REL], GoalVarList, L1, L3, Call) :-
	regexp_goal_var_list(Lexer, SemAct, RE, GoalVarList1, L1, L2, Call),
	regexp_seq_list(Lexer, SemAct, REL, GoalVarList2, L2, L3, Call),
	append(GoalVarList1, GoalVarList2, GoalVarList).
regexp_seq_list(_, _, [], [], L, L, _).
re_chars([re_char(C)|REL1], [C|CL], L1, REL2, L2, EGVL) :-
	llist_hd_tl(L1, chr(_, C), CHRL),
	re_chars(REL1, CL, CHRL, REL2, L2, EGVL).
re_chars([re_any|REL1], [C|CL], L1, REL2, L2, EGVL) :-
	llist_hd_tl(L1, chr(_, C), CHRL),
	re_chars(REL1, CL, CHRL, REL2, L2, EGVL).
re_chars([re_nor([re_char(C1)])|REL1], [C|CL], L1, REL2, L2, [no_sel(C \= C1, no_char)|EGVL]) :-
	llist_hd_tl(L1, chr(_, C), CHRL),
	re_chars(REL1, CL, CHRL, REL2, L2, EGVL).
re_chars(REL, [], L2, REL, L2, []).
ignore_return([no_sel(X, _)|GVL1], [no_sel(X, no_char)|GVL2]) :-
	ignore_return(GVL1, GVL2).
ignore_return([], []).
or_list_char_list([RE|REL], [CC|CCL]) :-
	or_char(RE, CC),
	or_list_char_list(REL, CCL).
or_list_char_list([], []).
goal_not_among([code(C1)], C, Goal, L1, L2) :-
	Goal = (llist_hd_tl(L1, chr(_, C), L2), C \= C1).
goal_not_among(CCL, C, Goal, L1, L2) :-
	Goal = char_not_among(CCL, C, L1, L2).
list_fold_right(X, [], X).
list_fold_right(Y, [Y], true).
list_fold_right((Y, Z), [Y|L], X) :-
	list_fold_right(Z, L, X).
regexp_list_repeator(Lexer, Index, SemAct, [RE|REL], Call) :-
	regexp_list_repeator(Lexer, Index, SemAct, REL, Call),
	equal_dot_dot(TokenArg, [Lexer, Index, R, L1, L3]),
	regexp_goal_var_list(Lexer, SemAct, RE, GoalVarList, L1, L2, Call),
	equal_dot_dot(Term, [Lexer, Index, CL, L2, L3]),
	goalvarlist_goallist(GoalVarList, GoalList1),
	goalvarlist_charlist(GoalVarList, CharList, ExtraGoalList),
	append(GoalList1, ExtraGoalList, GoalList2),
	agaga(GoalList2, CharList, CL, R, GoalList),
	list_fold_right(Goal, GoalList, Term),
	equal_dot_dot(CallArgs0, [Call, asserta((TokenArg :- Goal))]),
	call(CallArgs0).
regexp_list_repeator(_, _, _, [], _).
regexp_list_option(Lexer, Index, SemAct, [RE|REL], Call) :-
	regexp_list_option(Lexer, Index, SemAct, REL, Call),
	equal_dot_dot(TokenArg, [Lexer, Index, R, L1, L2]),
	regexp_goal_var_list(Lexer, SemAct, RE, GoalVarList, L1, L2, Call),
	goalvarlist_goallist(GoalVarList, GoalList1),
	goalvarlist_charlist(GoalVarList, CharList, ExtraGoalList),
	append(GoalList1, ExtraGoalList, GoalList2),
	GoalList = GoalList2,
	R = CharList,
	list_fold_right(Goal, GoalList, true),
	equal_dot_dot(CallArgs0, [Call, asserta((TokenArg :- Goal))]),
	call(CallArgs0).
regexp_list_option(_, _, _, [], _).
agaga(GoalList, CharList, CL, R, GoalList) :-
	nonvar(CharList),
	append(CharList, CL, R).
agaga(GoalList2, CharList, CL, R, GoalList) :-
	append(GoalList2, [append(CharList, CL, R)], GoalList).
or_char(re_interv(C1, C2), code_interv(C1, C2)).
or_char(re_char(C), code(C)).
regexp_index(Index) :-
	g_read(regexp_index, Index),
	N is Index + 1,
	g_assign(regexp_index, N).
lexer_parse_char_list([], L, L, true).
lexer_parse_char_list([Chr|ChrL], L1, L3, Goal3) :-
	Goal1 = llist_hd_tl(L1, chr(_, Chr), L2),
	lexer_parse_char_list(ChrL, L2, L3, Goal2),
	(Goal2 = true -> Goal3 = Goal1, !; Goal3 = (Goal1, Goal2)).
eq_frz(Var, X, Y, Val) :-
	(gen_invert -> Var = freeze_or(X, Y, Val); Var = Val).
big_or_list(re_big_or(RE1, RE2), [RE1|REL]) :-
	big_or_list(RE2, REL).
big_or_list(RE, [RE]).
sequence_list(re_seq(RE1, RE2), [RE1|REL]) :-
	sequence_list(RE2, REL).
sequence_list(RE, [RE]).
