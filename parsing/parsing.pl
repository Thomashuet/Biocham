% BIOCHAM system http://contraintes.inria.fr/BIOCHAM/
% Copyright 2003-2006, INRIA, Projet Contraintes
%
% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 2
% of the License, or (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
%
% GNU prolog file parsing.pl
% by Daniel de Rauglaudre

% This file has been generated by program: do not edit!
parsing_create_entry(Entry, Call) :-
	mod_atom_concat(Entry, '_priority_list', PrioList),
	(equal_dot_dot(CallArgs0, [Call, g_assign(PrioList, [])]), call(CallArgs0)),
	add_assert_entry(Entry, PrioList, Call),
	add_assert_entry_priol(Entry, Call),
	add_assert_entry_prio(Entry, PrioList, Call).
parsing_rule_asserta(Entry, Lexer, Prio, Rule, SemAct, Call) :-
	catch(parsing_rule_asserta_aux(Entry, Lexer, Prio, Rule, SemAct, Call), failure(Mess), throw(parsing_rule_asserta_error(Mess, Entry, Lexer, Prio, Rule, SemAct))).
parsing_rule_asserta_aux(Entry, Lexer, Prio, Rule, SemAct, Call) :-
	(integer(Prio) -> true; throw(failure('the priority is not an integer'))),
	mod_atom_concat(Entry, '_priority_list', PrioList),
	(equal_dot_dot(CallArgs0, [Call, g_read(PrioList, PL)]), call(CallArgs0)),
	(PL = 0 -> throw(failure('the entry does not exist')); true),
	parser_insert_priority(Entry, Prio, PL, NPL, Call),
	(equal_dot_dot(CallArgs1, [Call, g_assign(PrioList, NPL)]), call(CallArgs1)),
	parser_add_format_op(Entry, Lexer, Prio, Rule, SemAct, Call), !.
parsing_rule_asserta_aux(_, _, _, _, _, _) :-
	throw(failure('some parameters are incorrect')).
equal_dot_dot(:(Mod, Var), [:(Mod, Pred)|Args]) :-
	equal_dot_dot(Var, [Pred|Args]).
equal_dot_dot(Var, Val) :-
	Val \= [:(_, _)|_],
	Var =.. Val.
equal_dot_dot(Var, Val) :-
	Var \= [:(_, _)|_],
	Var =.. Val.
mod_atom_concat(:(M, X), Y, :(M, Z)) :-
	mod_atom_concat(X, Y, Z).
mod_atom_concat(X, Y, Z) :-
	X \= :(_, _),
	atom_concat(X, Y, Z).
parsing_token_attr_loc(Attr, BP, EP) :-
	g_read(parsing_token_attr_loc_pred, Pred),
	(Pred = 0 -> Attr = ta_loc(BP, EP); equal_dot_dot(PredArgs0, [Pred, Attr, BP, EP]), call(PredArgs0)).
parsing_token_attr_loc_pred(TAL) :-
	g_assign(parsing_token_attr_loc_pred, TAL).
set_gen_invert :-
	g_assign(gen_invert, true).
gen_invert :-
	g_read(gen_invert, true).
add_assert_entry(Entry, PrioList, Call) :-
	equal_dot_dot(Pred, [Entry, T, R1, R2]),
	Goal1 = g_read(PrioList, PL),
	equal_dot_dot(Goal2, [Entry, priol(PL), T, R1, R2]),
	Clause1 = (Pred :- Goal1, Goal2),
	equal_dot_dot(CallArgs0, [Call, assertz(Clause1)]),
	call(CallArgs0).
add_assert_entry_priol(Entry, Call) :-
	equal_dot_dot(Pred1, [Entry, priol([P1|PL1]), Y1, R11, R13]),
	equal_dot_dot(Goal1_1, [Entry, priol(PL1), X1, R11, R12]),
	equal_dot_dot(Goal1_2, [Entry, kont(P1, PL1, R11, X1), Y1, R12, R13]),
	(gen_invert -> equal_dot_dot(Goal1, [freeze_or, R11, X1, Goal1_1]), equal_dot_dot(Goal2, [freeze_or, X1, Y1, Goal1_2]); Goal1 = Goal1_1, Goal2 = Goal1_2),
	Clause1 = (Pred1 :- Goal1, Goal2),
	equal_dot_dot(CallArgs0, [Call, assertz(Clause1)]),
	call(CallArgs0).
add_assert_entry_prio(Entry, PrioList, Call) :-
	equal_dot_dot(Pred, [Entry, prio(P), X, R1, R2]),
	Goal1 = g_read(PrioList, PL),
	Goal2 = parsing_prio_less_equal(P, PL, PL2),
	equal_dot_dot(Goal3, [Entry, priol(PL2), X, R1, R2]),
	Clause = (Pred :- Goal1, Goal2, Goal3),
	equal_dot_dot(CallArgs0, [Call, assertz(Clause)]),
	call(CallArgs0).
parser_add_format_op(E, Lex, Prio, [x(Arg)|Rule], SemAct, Call) :-
	equal_dot_dot(Pred, [E, kont(Prio, PL, BT, X), Y, L1, L2]),
	format_op_goal(E, Lex, Prio, PL, Rule, GRL, L1, L2, Call),
	result_list(GRL, RL),
	goal_list(GRL, Goal1),
	(nonvar(SemAct), SemAct = call_act(PrP) -> PrP =.. [Pr|Pa], copy_term(Arg - Rule - Pa, X - RL - Pa1), append(Pa1, [Y, BT, L2], Pa2), Act1 =.. [Pr|Pa2]; copy_term(Arg - Rule - SemAct, X - RL - Y) -> Act1 = true; throw(failure('the semantic action is incorrect'))),
	(gen_invert, first_var(RL, V) -> equal_dot_dot(Goal, [freeze_or, L1, V, Goal1]), equal_dot_dot(Act, [freeze_or, V, Y, Act1]); Goal = Goal1, Act = Act1),
	(Act = true -> Clause = (Pred :- Goal); Clause = (Pred :- Goal, Act)),
	equal_dot_dot(CallArgs0, [Call, asserta(Clause)]),
	call(CallArgs0).
parser_add_format_op(E, Lex, Prio, [y(Arg)|Rule], SemAct, Call) :-
	equal_dot_dot(Pred, [E, kont(Prio, PL, BT, X), Z, L1, L3]),
	format_op_goal(E, Lex, Prio, PL, Rule, GRL, L1, L2, Call),
	result_list(GRL, RL),
	goal_list(GRL, Goal1),
	(nonvar(SemAct), SemAct = call_act(PrP) -> PrP =.. [Pr|Pa], copy_term(Arg - Rule - Pa, X - RL - Pa1), append(Pa1, [Y, BT, L3], Pa2), Act =.. [Pr|Pa2]; copy_term(Arg - Rule - SemAct, X - RL - Y) -> Act = true; throw(failure('the semantic action is incorrect'))),
	equal_dot_dot(Goal2, [E, kont(Prio, PL, BT, Y), Z, L2, L3]),
	(Act = true -> Clause = (Pred :- Goal1, Goal2); Clause = (Pred :- Goal1, Act, Goal2)),
	(equal_dot_dot(CallArgs0, [Call, asserta(Clause)]), call(CallArgs0)),
	true.
parser_add_format_op(E, Lex, Prio, Rule, SemAct, Call) :-
	equal_dot_dot(Pred, [E, priol([Prio|PL]), Y, L1, L2]),
	format_op_goal(E, Lex, Prio, PL, Rule, GRL, L1, L2, Call),
	result_list(GRL, RL),
	goal_list(GRL, Goal1),
	(nonvar(SemAct), SemAct = call_act(PrP) -> PrP =.. [Pr|Pa], copy_term(Rule - Pa, RL - Pa1), append(Pa1, [Y, L1, L2], Pa2), Act1 =.. [Pr|Pa2]; copy_term(Rule - SemAct, RL - Y) -> Act1 = true; throw(failure('the semantic action is incorrect'))),
	(gen_invert, first_var(RL, V) -> equal_dot_dot(Goal, [freeze_or, L1, V, Goal1]), equal_dot_dot(Act, [freeze_or, V, Y, Act1]); Goal = Goal1, Act = Act1),
	(Act = true -> Clause = (Pred :- Goal); Clause = (Pred :- Goal, Act)),
	equal_dot_dot(CallArgs0, [Call, asserta(Clause)]),
	call(CallArgs0).
first_var([H|_], H) :-
	var(H).
first_var([H|_], X) :-
	H =.. [_, X],
	var(X).
first_var([H|T], V) :-
	nonvar(H),
	first_var(T, V).
result_list([goal_res(_, R)|GRL], [R|RL]) :- !,
	result_list(GRL, RL).
result_list([], []) :- !.
result_list(GRL, _) :-
	format('parsing:result_list: internal error ~w\n', [GRL]),
	halt(50).
goal_list([goal_res(G, _)], G) :- !.
goal_list([goal_res(G, _)|GRL], (G, GL)) :- !,
	goal_list(GRL, GL).
goal_list([], true) :- !.
goal_list(GRL, _) :-
	format('parsing:goal_list: internal error ~w\n', [GRL]),
	halt(50).
format_op_goal(E, Lex, P, PL, [f(Oper)|Rule], [GR|GRL], L1, L3, Call) :-
	nonvar(Oper),
	atom(Oper),
	parser_oper_token(Lex, Oper, Tok, Call),
	Patt = tok(_, Tok),
	Goal = parsing_check_token(E, Patt, L1, L2),
	GR = goal_res(Goal, f(Oper)),
	format_op_goal(E, Lex, P, PL, Rule, GRL, L2, L3, Call), !.
format_op_goal(E, Lex, P, PL, [p(Pred, X)|Rule], [GR|GRL], L1, L3, Call) :-
	equal_dot_dot(Goal, [Pred, X, L1, L2]),
	GR = goal_res(Goal, p(Pred, X)),
	format_op_goal(E, Lex, P, PL, Rule, GRL, L2, L3, Call), !.
format_op_goal(E, Lex, P, PL, [t(Tok)|Rule], [GR|GRL], L1, L3, Call) :-
	Patt = tok(_, some(Tok)),
	Goal = parsing_check_token(E, Patt, L1, L2),
	GR = goal_res(Goal, t(Tok)),
	format_op_goal(E, Lex, P, PL, Rule, GRL, L2, L3, Call), !.
format_op_goal(E, Lex, P, PL, [x(Arg)|Rule], [GR|GRL], L1, L3, Call) :-
	var(Arg),
	equal_dot_dot(Goal, [E, priol(PL), X, L1, L2]),
	GR = goal_res(Goal, x(X)),
	format_op_goal(E, Lex, P, PL, Rule, GRL, L2, L3, Call), !.
format_op_goal(E, Lex, P, PL, [y(Arg)|Rule], [GR|GRL], L1, L3, Call) :-
	var(Arg),
	equal_dot_dot(Goal, [E, priol([P|PL]), X, L1, L2]),
	GR = goal_res(Goal, y(X)),
	format_op_goal(E, Lex, P, PL, Rule, GRL, L2, L3, Call), !.
format_op_goal(E, Lex, P, PL, [z(Arg)|Rule], [GR|GRL], L1, L3, Call) :-
	var(Arg),
	mod_atom_concat(E, '_priority_list', PrioList),
	Goal1 = g_read(PrioList, PL1),
	equal_dot_dot(Goal2, [E, priol(PL1), X, L1, L2]),
	Goal = (Goal1, Goal2),
	GR = goal_res(Goal, z(X)),
	format_op_goal(E, Lex, P, PL, Rule, GRL, L2, L3, Call), !.
format_op_goal(_, _, _, _, [], [], L, L, _) :- !.
format_op_goal(_, _, _, _, _, _, _, _, _) :-
	throw(failure('some parameters are incorrect')), !.
parser_oper_token(Lexer, Oper, Tok, Call) :-
	atom_codes(Oper, CL1),
	codes_lchrs(CL1, ChrL1),
	LexPrm =.. [Lexer, Tok, ChrL1, ChrL2],
	(equal_dot_dot(CallArgs0, [Call, LexPrm]), call(CallArgs0)),
	llist_nil(ChrL2).
parser_oper_token(Lexer, Oper, _, _) :-
	format('Cannot add operator ''~w'':\n', [Oper]),
	format('This operator is not accepted by lexer ''~q''.\n', [Lexer]),
	throw(parsing_rule_asserta_error2).
codes_lchrs([], LL) :-
	llist_nil(LL).
codes_lchrs([C|CL], LL) :-
	llist_hd_tl(LL, chr(0, C), RCL),
	codes_lchrs(CL, RCL).
parser_insert_priority(E, P, [], [P], Call) :-
	parser_add_default_rule(E, P, Call).
parser_insert_priority(_, P, [P|PL], [P|PL], _).
parser_insert_priority(E, P, [X|PL], [P, X|PL], Call) :-
	P > X,
	parser_add_default_rule(E, P, Call).
parser_insert_priority(E, P, [X|PL], [X|NPL], Call) :-
	parser_insert_priority(E, P, PL, NPL, Call).
parser_add_default_rule(E, P, Call) :-
	equal_dot_dot(Pred, [E, kont(P, _, _, X), X, L, L]),
	equal_dot_dot(CallArgs0, [Call, asserta(Pred)]),
	call(CallArgs0).
parsing_prio_less_equal(P, [P1|PL], [P1|PL]) :-
	P >= P1.
parsing_prio_less_equal(P, [P1|PL], RPL) :-
	P < P1,
	parsing_prio_less_equal(P, PL, RPL).
parsing_prio_less_equal(_, [], []).
parsing_call(P, Call) :-
	parsing_call(P, 0, Call).
parsing_call(P, BackMax, Call) :-
	g_read(g_furthest_token, FTsaved),
	g_assign(g_furthest_token, no_furthest_token - BackMax),
	(catch((equal_dot_dot(CallArgs0, [Call, P]), call(CallArgs0)), E, (g_assign(g_furthest_token, FTsaved), throw(E))) -> g_assign(g_furthest_token, FTsaved); g_read(g_furthest_token, FT - _), g_assign(g_furthest_token, FTsaved), parse_error(FT)).
parsing_check_token(ParserName, _, L1, _) :-
	llist_hd_tl(L1, T1, _),
	T1 = tok(ta_loc(BP1, _), _),
	g_read(g_furthest_token, T - BackMax),
	(T = furthest_token(_, tok(ta_loc(BP, _), _), _) -> (BP1 =< BP -> T = furthest_token(X, Y, Cnt), ((BackMax = 0; Cnt < BackMax) -> true; parse_error(T)), Cnt1 is Cnt + 1, g_assign(g_furthest_token, furthest_token(X, Y, Cnt1) - BackMax); g_assign(g_furthest_token, furthest_token(ParserName, T1, 0) - BackMax)); g_assign(g_furthest_token, furthest_token(ParserName, T1, 0) - BackMax)),
	fail.
parsing_check_token(_, Patt, L1, L2) :-
	llist_hd_tl(L1, Patt, L2),
	(g_read(g_trace_backtrack, 1) -> write_tok(Patt); true).
write_tok(tok(ta_loc(BP, EP), Tok)) :-
	g_read(glop, EP0),
	EP0 =< BP, !,
	write_nchars(' ', EP0, BP),
	write_tok_type(Tok),
	flush_output,
	select([], _, [], _, 50),
	g_assign(glop, EP).
write_tok(tok(ta_loc(_, EP), _)) :-
	g_read(glop, EP0),
	EP =< EP0, !,
	write_nchars('\b', EP, EP0),
	flush_output,
	select([], _, [], _, 50),
	g_assign(glop, EP).
write_tok(X) :-
	g_read(glop, EP0),
	format('\nnot impl ~q ~q\n', [X, EP0]),
	halt(2).
write_tok_type(X) :-
	compound(X),
	X =.. [_, P],
	write(P), !.
write_tok_type(X) :-
	format('\nnot impl ~q\n', [X]),
	halt(2).
write_nchars(_, I, I) :- !.
write_nchars(S, I, J) :-
	write(S),
	K is I + 1,
	write_nchars(S, K, J).
parse_error(_) :-
	(g_read(g_trace_backtrack, 1) -> nl, fail).
parse_error(no_furthest_token) :- !,
	fail.
parse_error(furthest_token(_, tok(_, none), _)) :- !,
	fail.
parse_error(furthest_token(ParserName, tok(Attr, _), _)) :-
	parsing_token_attr_loc(Attr, BP, EP),
	Err = parsing_error(ParserName),
	throw(exc_loc(BP, EP, Err)).
new_index(Index) :-
	g_read(parser_index, Index),
	N is Index + 1,
	g_assign(parser_index, N).
freeze_or(_, _, _) :-
	format('\nfreeze_or not implemented\n  ~q\n', []),
	halt(2).
