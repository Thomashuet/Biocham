% BIOCHAM system http://contraintes.inria.fr/BIOCHAM/
% Copyright 2003-2010, INRIA, Projet Contraintes
%
% This program is free software; you can redistribute it and/or
% modify it under the terms of the GNU General Public License
% as published by the Free Software Foundation; either version 2
% of the License, or (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program; if not, write to the Free Software
% Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
%
% GNU prolog file biochamNuSMV.pl by Nathalie Chabrier, Francois Fages, Sylvain Soliman
 
% Parsing NuSMV output
:-dynamic(nusmv_pid/1). % stores the pid of the child process nusmv
:-dynamic(nusmv_line/1).
:-dynamic(nusmv_path/2).   % stores the rules used and the state changes
:-dynamic(last_query/3).   % stores last translated NuSMV request and answer
                           % (for 'why')
:-dynamic(last_path/1).

:-dynamic(nusmv_fairness_path/0).
%:-dynamic(spec/1).
:-dynamic(spec/3). %spec(Query,posi_negativ_or_undefin,last_answers)
:-dynamic(pathway/2). % pathway(NegativeQueryFalse,Path)
:-dynamic(dynamic_order_method/1).
:-dynamic(no_false_initial_state/0). % pour ne pas avoir le faux �tat initial de NuSMV (acc�l�rer les tmps de calculs).

nusmv_direct:-
	assertz(no_false_initial_state),
	assertz(rules_added).
nusmv_non_direct:-
	retractall(no_false_initial_state),
	assertz(rules_added).


% Exports BIOCHAM to NuSMV 

%%% writes the rules into a NuSMV file F.
export_nusmv(F):-
   \+(atom(F)),!,
  
        (
                have_gui
        ->
                format("[GUI] errors Filename must be an atom, or be enclosed in simple quotes.~n",[])
        ;
   write_line_col('Error'),
                write('Filename must be an atom, or be enclosed in simple quotes\n')
        ).

export_nusmv(F):-
   (sub_atom(F,_,_,0,'.smv') -> G=F ; atom_concat(F,'.smv',G)),
        open(G, write, _, [alias(nusmv)]),
   write(nusmv,'-- Model generated by BIOCHAM'),nl(nusmv),nl(nusmv),
   write(nusmv,'MODULE main'),nl(nusmv),nl(nusmv),
   nusmv_initial_state(LM),
   nusmv_rules(LM),
   
   (
     nusmv_fairness_path
   ->
     (
       format_debug(2,"export pour modele avec fairness~n",[]),
       nusmv_fairness
     );
     true
   ),
   close(nusmv),
   !.

%%% describes the initial state
nusmv_initial_state(LM) :-
   write(nusmv,'VAR'),nl(nusmv),
   (
     nusmv_fairness_path
   ->
     (
	write_declaration_rule
     )
   ;
     (
       findall(R,rule(R,_,_,_,_,_,_),LR),
       length(LR,N),		% get the number of rules
       (
	 no_false_initial_state
       ->
	 ( format(nusmv,"R : 1..~d;~n",[N]))
       ;
	 ( format(nusmv,"R : 0..~d;~n",[N]))
       )
     )
   ),
   nusmv_search_molecules, 
%   search_all_molecules,
   findall(M,molecule(M,_),LM),     % get all the molecules
   nusmv_write_molecule_rec(LM),
    (
     nusmv_fairness_path
   ->
      (
	(
	  no_false_initial_state
	->
	  (
	    format(nusmv,"~nASSIGN~ninit(R) := {",[]),
	    g_assign(num_R,0),
	    assertz(first),
	    iter_write_declaration_rule,
	    retractall(first),
	    format(nusmv,"};~nnext(R) := {",[])
	  )
	;
	  ( format(nusmv,"~nASSIGN~ninit(R) := _0;~nnext(R) := {",[]) )
	),
	g_assign(num_R,0),
	assertz(first),
	iter_write_declaration_rule,
	retractall(first),
	write(nusmv,'};'), nl(nusmv)
      )
    ;
      (
         (N<2)
      ->
	(
	  no_false_initial_state
	->
	  ( format(nusmv,"~nASSIGN~ninit(R) := 1;~nnext(R) := 1;~n",[N]))
	;
	  ( format(nusmv,"~nASSIGN~ninit(R) := 0;~nnext(R) := 1;~n",[N]))
	)
      ;
	(
	  no_false_initial_state
	->
	  ( format(nusmv,"~nASSIGN~ninit(R) :=  1..~d;~nnext(R) := 1..~d;~n",[N,N]))
	;
	  ( format(nusmv,"~nASSIGN~ninit(R) := 0;~nnext(R) := 1..~d;~n",[N]))
	)
      )
    ).







% rule's name is _N_B where N is biocham rule's number and B is a binary number on m bits where m is the number of rule's molecules only in left part(and not unique).  (0 molecule is consumed, 1  is not consumed) each bit is separated by  a "_".
% rule 0 is for the "initial state"
write_declaration_rule:-
	(
	  no_false_initial_state
	->
	  ( assertz(first),write(nusmv,'R : {'))
	;
	  ( write(nusmv,'R : {_0'))
	),
	g_assign(num_R,0),
	
	iter_write_declaration_rule,
	write(nusmv,'};'), nl(nusmv).


iter_write_declaration_rule:-
	rule(_,L1,L2,_,_,_,_),
	g_read(num_R,Num_R_old),
	Num_R is Num_R_old+1 ,
	g_assign(num_R,Num_R),
   
	forget_stoichiometry(L1,LL),
	forget_stoichiometry(L2,LR),

	write_all_num_rule(Num_R,LL,LR),
	fail.

iter_write_declaration_rule.

% write all number of the rule Num_R.
write_all_num_rule(Num_R,LL,LR):-
	write_all_num_rule(Num_R,LL,LR,_,_).

% write all number of the rule Num_R where the Mol is Val (boolean)
write_all_num_rule(Num_R,LL,LR,Mol,Val):-
	findall(M,member_not_catalist_not_unique(M,LL,LR),LMp),
	sort(LMp,LM),  % to eliminate molecule occurence
	length(LM,Nmol),
	
	(
	  Nmol==0
	->
	  (retract(first) ->format(nusmv,' _~d',[Num_R])  ; format(nusmv,', _~d',[Num_R])) ;
	  (nonvar(Mol)  ->  nth(Num,LM,Mol) ;   true),
	  iter_write_declaration_rule_bis(Nmol,Num,Val)
	).

member_not_catalist(M,LL,LR):-
	member(M,LL),
	\+(member(M,LR)).
member_not_unique(M,LL):-
	member(M,LL),
	\+(uniq(M)).

member_not_catalist_not_unique(M,LL,LR):-
	member(M,LL),
	\+(member(M,LR)),
	\+(uniq(M)).


iter_write_declaration_rule_bis(Nmol,Num,Val):-
	length(L,Nmol),
	(
	  nonvar(Num) ->  nth(Num, L, Val); true),
	iter_write_declaration_rule_bis_coprs(L).

iter_write_declaration_rule_bis(Nmol):-
	iter_write_declaration_rule_bis(Nmol,_,_).

iter_write_declaration_rule_bis_coprs(L):-
	findall(L,nombre_binaire(L),ListL),
	g_read(num_R,Num_R),
	write_all_num_Rbis(ListL,Num_R).

nombre_binaire([B]):-
	(B=0 ; B=1).
nombre_binaire([B|L]):-
	(B=0 ; B=1),
	nombre_binaire(L).
	
	
write_all_num_Rbis([],_).

write_all_num_Rbis([L|ListL],Num_R):-
	(retract(first) ->	format(nusmv,' _~d',[Num_R]);
	format(nusmv,', _~d',[Num_R])),
	write_list_num_Rbis(L),
	write_all_num_Rbis(ListL,Num_R).

	
write_list_num_Rbis([]).
write_list_num_Rbis([B|L]):-
	format(nusmv,'_~d',[B]),
	write_list_num_Rbis(L).
	
fairness_path:-
	assertz(nusmv_fairness_path),
	assertz(rules_added).
no_fairness_path:-
	retractall(nusmv_fairness_path),
	assertz(rules_added).





nusmv_fairness:-
   g_assign(num_R,0),
   nl(nusmv),
   nl(nusmv),
   write(nusmv,'-- fairness of rules\tapplication'),
   nl(nusmv),
   iter_fairness,
   nl(nusmv).



iter_fairness:-
	rule(R,L1,L2,_,_,_,_),
	forget_stoichiometry(L1,LL),
	forget_stoichiometry(L2,LR),
	g_read(num_R,Old),
	New is Old+1,
	g_assign(num_R,New),

	(
	  R = (Name:_)
	->
	  format(nusmv,"-- ~w.~n",[Name])
	;
	  true
	),			% give its name
	

	iter_fairness_same_rule(New,LL,LR),
	nl(nusmv),
	fail.

iter_fairness.

iter_fairness_same_rule(Num_R,LL,LR):-
	findall(M,member_not_catalist_not_unique(M,LL,LR),LMp),
	sort(LMp,LM),		% to eliminate molecule occurence
	length(LM,Nmol),
	(
	  Nmol==0
	->
	  (
	    nusmv_fairness_path  ->
	    (
	      format(nusmv,"FAIRNESS ~c( ",[9]),
	      (LL==[] -> write(nusmv,'TRUE') ; write_condition(LL)),
	      format(nusmv," )  -> R = _~d;~n",[Num_R])
	    );
	    (
	      format(nusmv,"COMPASSION  (  (",[]),
	      (LL==[] -> write(nusmv,'TRUE') ; write_condition(LL)),
	      format(nusmv," )  ,  R = _~d);~n",[Num_R])
	    )
	  )
	;
	  (
	    length(L,Nmol),
	    findall(L,nombre_binaire(L),ListL),
	    iter_fairness_same_rule_bis(Num_R,ListL,LL)
	  )
	).

iter_fairness_same_rule_bis(_,[],_).
iter_fairness_same_rule_bis(Num_R,[L|ListL],LL):-
	 ( nusmv_fairness_path  ->
	     (   format(nusmv,"FAIRNESS ~c( ",[9]),
		 write_condition(LL),
		 format(nusmv," )  -> R = _~d",[Num_R]),
		 write_list_num_Rbis(L),
		 format(nusmv,";~n",[])
	     );
	     (
	       format(nusmv,"COMPASSION  (  (",[]),
	       write_condition(LL),
	       format(nusmv," )  ,  R = _~d",[Num_R]),
	       write_list_num_Rbis(L),
	       format(nusmv," );~n",[])
	     )
	 ),
	 iter_fairness_same_rule_bis(Num_R,ListL,LL).
	





%%% write a list of molecules as NuSMV atoms
nusmv_write_molecule_rec([]).
nusmv_write_molecule_rec([M|LM]) :-
   nusmv_write_molecule(M),
   write(nusmv,' : boolean;'),
   nl(nusmv),
   nusmv_write_molecule_rec(LM).

%%% write one molecule as a NuSMV atom
nusmv_write_molecule(M) :-
   nusmv_molecule_to_atom(M,A),
   write(nusmv,A).

%%% convert a molecule to a parenthesised NuSMV atom
%nusmv_molecule_to_atom_par(A-B,S) :-
%   nusmv_molecule_to_atom(A-B,S1),
%   atom_concat('_lpar_',S1,S2),
%   atom_concat(S2,'_rpar_',S),!.

%nusmv_molecule_to_atom_par(A,S) :-
%   nusmv_molecule_to_atom(A,S).

%%% convert a molecule to a NuSMV atom
nusmv_molecule_to_atom(A::B,S) :-
   nusmv_molecule_to_atom(A,S1),
   atom_concat(S1,'_z',S2),          % complexation remains '-'
   nusmv_molecule_to_atom(B,S3),
   %nusmv_molecule_to_atom_par(B,S3),
   atom_concat(S2,S3,S),!.

nusmv_molecule_to_atom(A-B,S) :-
   nusmv_molecule_to_atom(A,S1),
   atom_concat(S1,'-',S2),          % complexation remains '-'
   nusmv_molecule_to_atom(B,S3),
   %nusmv_molecule_to_atom_par(B,S3),
   atom_concat(S2,S3,S),!.

nusmv_molecule_to_atom(A~{B},S) :-
   nusmv_molecule_to_atom(A,S1),
   ((A = _-_) -> 
      (atom_concat('_L',S1,S11),
         atom_concat(S11,'_R',S12));
      (S12 = S1)),
   atom_concat(S12,'_l',S2),  % beginning of phosphorylation
   goal_to_list(B,L),
   nusmv_molecules_to_atom(L,S3),
   atom_concat(S2,S3,S4),
   atom_concat(S4,'_r',S),!.         % end of phosphorylation

nusmv_molecule_to_atom(@(A),S) :-   % control variable
   atom_concat('_$',A,S),!.

nusmv_molecule_to_atom(#(A),S) :-   % gene
   atom_concat('_#',A,S),!.

% B, H, O, S, T, V, W, Y, Z are reserved names for NuSMV
nusmv_molecule_to_atom('B','_B'):-!.
nusmv_molecule_to_atom('F','_F'):-!.
nusmv_molecule_to_atom('G','_G'):-!.
nusmv_molecule_to_atom('H','_H'):-!.
nusmv_molecule_to_atom('O','_O'):-!.
nusmv_molecule_to_atom('S','_S'):-!.
nusmv_molecule_to_atom('T','_T'):-!.
nusmv_molecule_to_atom('V','_V'):-!.
nusmv_molecule_to_atom('W','_W'):-!.
nusmv_molecule_to_atom('X','_X'):-!.
nusmv_molecule_to_atom('Y','_Y'):-!.
nusmv_molecule_to_atom('Z','_Z'):-!.
% plus usual operators
nusmv_molecule_to_atom('A','_A'):-!.
nusmv_molecule_to_atom('E','_E'):-!.
nusmv_molecule_to_atom('U','_U'):-!.
nusmv_molecule_to_atom('AF','_AF'):-!.
nusmv_molecule_to_atom('EF','_EF'):-!.
nusmv_molecule_to_atom('AG','_AG'):-!.
nusmv_molecule_to_atom('EG','_EG'):-!.
nusmv_molecule_to_atom('AX','_AX'):-!.
nusmv_molecule_to_atom('EX','_EX'):-!.
nusmv_molecule_to_atom('xor','_xor'):-!.

% and R is used for our rules
nusmv_molecule_to_atom('R','__'):-!.

nusmv_molecule_to_atom(A,S) :-
   atom(A) -> 
      (atom_codes(A,C),
         double_underscore(C,D),
         atom_codes(S,D));
        (
                have_gui
        ->
                format("[GUI] errors (NUSMV) garbled while converting to NuSMV syntax molecule ~w.~n",[A])
        ;
                true
        ),
throw('Error: garbled while converting to NuSMV syntax molecule '(A)).

% _ is coded as __, _ has 95 as code.
double_underscore([],[]).
double_underscore([95|T],[95,95|TT]):-
   !,double_underscore(T,TT).
double_underscore([H|T],[H|TT]):-
   double_underscore(T,TT).

%%% convert a list of molecules to NuSMV atoms
nusmv_molecules_to_atom([M],S):-
   !,nusmv_molecule_to_atom(M,S).

nusmv_molecules_to_atom([M|LM],S) :-
   nusmv_molecule_to_atom(M,S1),
   atom_concat(S1,'_c',S2),       % separates phosphorylation sites
   nusmv_molecules_to_atom(LM,S3),
   atom_concat(S2,S3,S).

%%% write rules as NuSMV transitions, by iterating on a list of molecules
nusmv_rules([]).

nusmv_rules([M|LM]) :-
   nl(nusmv),write(nusmv,'ASSIGN'),nl(nusmv),
   write(nusmv,'init('),nusmv_write_molecule(M),    %  initial state
   write(nusmv,') :='),
   (
     no_false_initial_state
   ->
     (
       (init_present(M) -> write(nusmv,'TRUE'); % 'real' initial state
	   (init_absent(M) -> write(nusmv,'FALSE');
	       (write(nusmv,'{FALSE, TRUE}')))),
       write(nusmv,';'),nl(nusmv),
       write(nusmv,'next('),nusmv_write_molecule(M),
       write(nusmv,') := case'),nl(nusmv)
     )
   ;
     (
       write(nusmv,'FALSE;'),nl(nusmv),	% is always FALSE (fake) initial state
       write(nusmv,'next('),nusmv_write_molecule(M),
       write(nusmv,') := case'),nl(nusmv),
       (
	 nusmv_fairness_path
       ->
	 (
	   format(nusmv,"~cR = _0 : ",[9]) % char 9 is a tabulation
	 );
	 (
	   format(nusmv,"~cR = 0 : ",[9]) % char 9 is a tabulation
	 )
       ),
       (init_present(M) -> write(nusmv,'TRUE'); % 'real' initial state
	   (init_absent(M) -> write(nusmv,'FALSE');
	       (write(nusmv,'{FALSE, TRUE}')))),
       write(nusmv,';'),nl(nusmv)
     )
   ),
   iter_rules(M),		% now iterate on rules
   format(nusmv,"~cTRUE : ",[9]),nusmv_write_molecule(M),
   write(nusmv,';'),nl(nusmv),
   format(nusmv,"~cesac;~n",[9]),
   nusmv_rules(LM).

%%% for one given molecule, iterate on rules that may change its state
iter_rules(M) :-
   g_assign(num_R,0),
   rule(R,L1,L2,_,_,_,_),
   forget_stoichiometry(L1,LL),
   forget_stoichiometry(L2,LR),
   g_read(num_R,Old),
   New is Old+1,
   g_assign(num_R,New),
   (
     member(M,LR)
   ->				% we got a rule with M on the right
     (
       (
	 R = (Name:_)
       ->
	 format(nusmv,"-- ~w.~n",[Name])
       ;
	 true
       ),			% give its name
       member(M,LL)
     ->				% M on the left too: catalyst
       format(nusmv,"-- catalyseur de la regle ~d.~n",[New])
     ;
       (
	 LL = []		% no condition
       ->
	 ( 
	   nusmv_fairness_path ->
	   (
	     format(nusmv,"~cR in { ",[9]), % make M present
	     assertz(first),
	     write_all_num_rule(New,LL,LR),
	     retractall(first),
	     format(nusmv,"} : TRUE;~n ",[]) % make M true
	   )
	 ;
	   (format(nusmv,"~cR = ~d : TRUE;~n ",[9,New])) % make M true
	 )
       ;			% else makes M TRUE when the condition is met
	 ( 
	   (
	     nusmv_fairness_path ->
	     (
	       format(nusmv,"~cR in { ",[9]),
	       assertz(first),
	       write_all_num_rule(New,LL,LR),
	       retractall(first),
	       format(nusmv,"} : case~n~2c(",[9])
	     )
	   ;
	     (
	       format(nusmv,"~cR = ~d : case",[9,New]),
	       format(nusmv,"~n~2c(",[9])
	     )
	   ),
	   write_condition(LL),
	   format(nusmv,") : TRUE;~n~2cTRUE : ",[9]),
	   nusmv_write_molecule(M),
	   format(nusmv,";~n~2cesac;~n",[9])
	 )
       )
     )
   ;
     (
       member(M,LL)
     ->
       (
	 (R = (Name:_)
         ->
	     format(nusmv,"-- ~w.~n",[Name]); true),
				% M on the left but not the right, give the name
	 (
	   nusmv_fairness_path ->
	   ( format(nusmv,"~cR in {",[9]))
	 ;
	   (
	     format(nusmv,"~cR = ~d : case~n~2c(",[9,New,9]),
	     write_condition(LL) % if condition
	   )
	 ),
	 (
	   uniq(M)
	 ->			% if GENE or such
	   (
	     nusmv_fairness_path ->
	     (
	       assertz(first),
	       write_all_num_rule(New,LL,LR),
	       retractall(first)
	     )
	   ;
	     (  format(nusmv,") : FALSE;",[]))	% M is 'consumed'
	   )
	 ;
	   (
	     nusmv_fairness_path ->
	     (
	       assertz(first),
	       write_all_num_rule(New,LL,LR,M,1),
	       retractall(first),
	       format(nusmv,"} : case~n~2c(",[9]),
	       write_condition(LL),
	       format(nusmv,") : TRUE;~n~2cTRUE : ",[9]),
	       nusmv_write_molecule(M),format(nusmv,";~n~2cesac;~n",[9]),
	       format(nusmv,"~cR in {",[9]),
	       assertz(first),
	       write_all_num_rule(New,LL,LR,M,0),
	       retractall(first)
	     )
	   ;
	     (format(nusmv,") : {FALSE, TRUE};",[])) % M can be T or F
	   )
	 ),
	 (
	   nusmv_fairness_path ->
	   (
	     format(nusmv,"} : case~n~2c(",[9]),
	     write_condition(LL),
	     format(nusmv,") : FALSE;~n~2cTRUE : ",[9])
	   )
	 ;
	   (format(nusmv,"~n~2cTRUE : ",[9]))
	 ),
	 nusmv_write_molecule(M),format(nusmv,";~n~2cesac;~n",[9])
       )
     ;
       true
     )
   ),
   fail.

iter_rules(_).

%%% write a list of molecules as a conjunction condition
write_condition([A]) :-
   nusmv_write_molecule(A).

write_condition([A,B|L]) :-
   nusmv_write_molecule(A),
   write(nusmv,' & '),
   write_condition([B|L]).

%%% get all molecules, including those in the initial state but in no rule
nusmv_search_molecules :-
   retractall(molecule(_,_)),
   nusmv_search_init_molecules,  % this one first to get the right order
   nusmv_search_rules_molecules.

%%% same as search_molecule from biocham.pl but no retractall...
nusmv_search_rules_molecules :-
   rule(_,LL,LR,_,_,_,_),
   add_molecules(LL),
   add_molecules(LR),
   fail.

nusmv_search_rules_molecules.

%%% get molecules from the initial state
nusmv_search_init_molecules :-
   initconc(A,_),
   add_molecules([(_,A)]),
   fail.

nusmv_search_init_molecules.

%%% define CTL queries operators
:- op(500,yfx,'U').
:- op(500,yfx,'&').
% :- op(500,yfx,'|').
:- op(500,yfx,'xor').
:- op(500,yfx,'->').
:- op(500,yfx,'<->').


nusmv_negation_query(Q1, S) :-
	atom_concat('AX',Q,Q1),
	!,
	atom_concat('EX(!',Q,S1),
	atom_concat(S1,')',S).
   

nusmv_negation_query(Q1,S) :-
	atom_concat('EX',Q,Q1),
	!,
	atom_concat('AX(!',Q,S1),
	atom_concat(S1,')',S).


%%% translate a query, forgetting the fake initial state and  shortcuts for common queries (checkpoint, reachable, stable, reache_stable, loop...)

nusmv_translate('Ai'(Q),Q1) :-
 (
   no_false_initial_state
 ->
   ( Q1=Q )%, format("pas de faux  etat initial, Q1=~w~n",[Q1]))
 ;
  ( Q1='AX'(Q))%, format("Avec faux  etat initial, Q1=~w~n",[Q1]))
 ),
 !.

nusmv_translate('Ei'(Q),Q1):-
 (
   no_false_initial_state
 ->
   ( Q1=Q )%, format("pas de faux  etat initial, Q1=~w~n",[Q1]))
 ;
   (Q1='EX'(Q))%, format("Avec faux  etat initial, Q1=~w~n",[Q1]))
 ),
 !.

nusmv_translate(Q,Q) :-
(
 no_false_initial_state
->
 true	%(write('pas d etat initial'),nl)
;
 ( (
                have_gui
        ->
                format("[GUI] checkCTL Error: Initial state operator Ei()/Ai() missing.~n",[])
        ;
                true
        ),throw('Error: initial state operator Ei()/Ai() missing'))
).

%%% translate a query as a NuSMV atom

nusmv_translate_query(reachable(Q1),S) :- !,
   nusmv_translate_query('EF'(Q1),S).

nusmv_translate_query(stable(Q1),S) :- !,
   nusmv_translate_query('AG'(Q1),S).

nusmv_translate_query(steady(Q1),S) :- !,
   nusmv_translate_query('EG'(Q1),S).

nusmv_translate_query(oscil(X),S) :- !, % the weakness of CTL
   nusmv_translate_query('AG'('&'('->'(X,'EF'('!'(X))),'->'('!'(X),'EF'(X)))), S).

nusmv_translate_query(loop(X,Y),S) :- !,
   nusmv_translate_query('AG'('&'('->'(X,'EF'(Y)),'->'(Y,'EF'(X)))),S).

nusmv_translate_query(checkpoint(X,Y),S) :- !,
%   nusmv_translate_query('AG'('->'('!'(Y),'!'('E'('U'('!'(X),Y))))),S).
   nusmv_translate_query('!'('E'('U'('!'(X),Y))),S).

nusmv_translate_query('EF'(Q1),S) :-
   !,nusmv_translate_query(Q1,Q2),
   atom_concat('EF(',Q2,S1),
   atom_concat(S1,')',S).

nusmv_translate_query('AF'(Q1),S) :-
   !,nusmv_translate_query(Q1,Q2),
   atom_concat('AF(',Q2,S1),
   atom_concat(S1,')',S).

nusmv_translate_query('EG'(Q1),S) :-
   !,nusmv_translate_query(Q1,Q2),
   atom_concat('EG(',Q2,S1),
   atom_concat(S1,')',S).

nusmv_translate_query('AG'(Q1),S) :-
   !,nusmv_translate_query(Q1,Q2),
   atom_concat('AG(',Q2,S1),
   atom_concat(S1,')',S).

nusmv_translate_query('EX'(Q1),S) :-
   !,nusmv_translate_query(Q1,Q2),
   atom_concat('EX(',Q2,S1),
   atom_concat(S1,')',S).

nusmv_translate_query('AX'(Q1),S) :-
   !,nusmv_translate_query(Q1,Q2),
   atom_concat('AX(',Q2,S1),
   atom_concat(S1,')',S).

nusmv_translate_query('E'(Q1),S) :-
   !,nusmv_translate_query(Q1,Q2),
   atom_concat('E[',Q2,S1),
   atom_concat(S1,']',S).

nusmv_translate_query('A'(Q1),S) :-
   !,nusmv_translate_query(Q1,Q2),
   atom_concat('A[',Q2,S1),
   atom_concat(S1,']',S).

nusmv_translate_query(Q1 'U' Q2,S) :-
   !,nusmv_translate_query(Q1,S1),
   nusmv_translate_query(Q2,S2),
   format_to_atom(S,"~w U ~w",[S1,S2]).
   %atom_concat(S1,' U ',S3),
   %atom_concat(S3,S2,S).

nusmv_translate_query(!(Q1),S) :-
   !,nusmv_translate_query(Q1,Q2),
   atom_concat('!',Q2,S).

nusmv_translate_query(Q1 & Q2,S) :-
   !,nusmv_translate_query(Q1,S1),
   nusmv_translate_query(Q2,S2),
   format_to_atom(S,"(~w & ~w)",[S1,S2]).
   %atom_concat(S1,' & ',S3),
   %atom_concat(S3,S2,S).

nusmv_translate_query('|'(Q1, Q2),S) :-
   !,nusmv_translate_query(Q1,S1),
   nusmv_translate_query(Q2,S2),
   format_to_atom(S,"(~w | ~w)",[S1,S2]).
   %atom_concat(S1,' | ',S3),
   %atom_concat(S3,S2,S).

nusmv_translate_query(Q1 'xor' Q2,S) :-
   !,nusmv_translate_query(Q1,S1),
   nusmv_translate_query(Q2,S2),
   format_to_atom(S,"(~w xor ~w)",[S1,S2]).
   %atom_concat(S1,' xor ',S3),
   %atom_concat(S3,S2,S).

nusmv_translate_query(Q1 -> Q2,S) :-
   !,nusmv_translate_query(Q1,S1),
   nusmv_translate_query(Q2,S2),
   format_to_atom(S,"(~w -> ~w)",[S1,S2]).
   %atom_concat(S1,' -> ',S3),
   %atom_concat(S3,S2,S).

nusmv_translate_query(Q1 <-> Q2,S) :-
   !,nusmv_translate_query(Q1,S1),
   nusmv_translate_query(Q2,S2),
   format_to_atom(S,"(~w <-> ~w)",[S1,S2]).
   %atom_concat(S1,' <-> ',S3),
   %atom_concat(S3,S2,S).

nusmv_translate_query(Q1,Q2) :-
   % Don't forget parse_object, to sort the order of phosphorylation sites
   parse_object(Q1,Q3),!,
   (
      rules_added
   ->
     nusmv_search_molecules
   ;
      true
   ),
   (
      molecule(Q3,_)      % check that the molecule exists
   ->
      nusmv_molecule_to_atom(Q3,Q2)
   ;
      
        (
                have_gui
        ->
                format("[GUI] checkCTL Error: molecule ~w is not defined.~n",[Q1]),
                format("[GUI] errors Molecule ~w is not definied.~n",[Q1])
        ;
      write_line_col('Error'),
                format("molecule ~w is not defined.~n",[Q1])
        ),      
      fail
   ).




% lance NuSMV 

launch:-
   start_nusmv,
   assertset(nusmv_running),
%   nusmv_err_out_put,
   nusmv_load.

% checks that there are rules to give to NuSMV, if necessary starts NuSMV and
% if necessary reloads the ruleset


nusmv_load :-
   \+(rule(_,_,_,_,_,_,_)),!,
   (
                have_gui
        ->
                format("[GUI] errors You must define a set of rules.~n",[]),
                format("[GUI] checkCTL Error: You must define a set of rules first.~n",[])
        ;
   write_line_col('Error'),
   write('you must load a set of rules (with load_biocham(file_bc)'),
                write(' or\nwith add_biocham(file_bc) or with add_rule(R))\n')
        ),
        fail.

nusmv_load:-   
   \+(nusmv_running),
   launch.

nusmv_load :-
	rules_added,
	g_read(nb_reload,N),
	Np is N -1,
	g_assign(nb_reload,Np),
	Np <0,
	!,
	nusmv_close,
	launch.


nusmv_load :-
   % rules_added: rules or initial state modified since last NuSMV export
   (
     rules_added
   ->
     (create_file_tmp, nusmv_reload)
   ;
     (dynamic_order_method(M) -> nusmv_dynamic_reordering(M); true)
   ).

% Exports to SMV file

create_file_tmp:-
   smv_file(F),
   export_nusmv(F),                 % export to that file
   retractall(rules_added).         % state that current state = exported

% Creates the pipes and parse NuSMV header

start_nusmv:-
	g_assign(nb_reload,10),	 % FIXME
   (
      find_in_path('NuSMV',Nusmv),!
   ;
      
        (
                have_gui
        ->
                format("[GUI] checkCTL Error: NuSMV not found in PATH.~n",[]),
                format("[GUI] errors NuSMV not found in PATH.~n",[])
   ;
                write_error('NuSMV not found in PATH')
        ),
      fail
   ),
   %os_version(OS),
   % spawn_redirect is now usable on all platforms
   %(
   %   atom_concat('CYGWIN',_,OS)
   %->
      % no bash nor grep, pray for the right NuSMV version
      format_debug(5,"Cmd: ~w -dcx -int~n",[Nusmv]),
      spawn_redirect(Nusmv, ['-dcx', '-int'],SIn,SOut,SOutErr,Pid),
   %  true
   %;
   %   format_to_atom(Commande,
   %      "/bin/bash -c \"'~w' -dcx -int 2> /dev/null\"",[Nusmv]),
   %   exec(Commande,SIn,SOut,SOutErr,Pid)
   %),
   retractall(nusmv_pid(_)),
   assertset(nusmv_pid(Pid)),
   add_stream_alias(SIn,nusmv_in),
   add_stream_alias(SOut,nusmv_out),
   add_stream_alias(SOutErr,nusmv_out_err),
   nusmv_read_header.

% (re)load the .smv file

nusmv_reload:-
   smv_file(F),
   format_debug(4,"write for nusmv:reset~nread_model -i \"~w\"~n",[F]),
   format(nusmv_in,"reset~nread_model -i \"~w\"~n",[F]),
   flush_output(nusmv_in),
   nusmv_read_prompt, % reset
   nusmv_read_prompt, % read_model
   (dynamic_order_method(M) -> nusmv_dynamic_reordering(M); true),
   format_debug(4,"write for nusmv: go~n",[]),
   format(nusmv_in,"go~n",[]),
   flush_output(nusmv_in),
   nusmv_read_prompt,	% go
   !.

% removes the temp .smv file and if necessary closes the pipe by quitting
% NuSMV

nusmv_close:-
   smv_file(Smv),
   unlink(Smv),
   (
      nusmv_running
   ->
     (
       retractall(nusmv_running),
       format_debug(4,"write in nusmv quit~n",[]),
       write(nusmv_in,'quit\n'),
       flush_output(nusmv_in),
       nusmv_pid(Pid),
       wait(Pid, _),         % wait the end of nusmv (to avoid crasy shell)
       close(nusmv_in),
       close(nusmv_out),
       
       close(nusmv_out_err)
     )
   ;
      true
   ),
   smv_file_out_err(Smv_out_err),
   unlink(Smv_out_err).
  % ,
%   smv_file_out(Smv_out),
%   unlink(Smv_out).

% Read header, that is 4 lines (actually one could check that they start with
% *** 
% but...

nusmv_read_header:-
   format_debug(5,"Reading header~n",[]),
   peek_char(nusmv_out, C1),
   format_debug(6, "~w~n", [C1]),
   (
      (
         C1 = (*)
      ;
         C1 = 'W'
      )
   ->
      format_debug(6, "header", []),
      nusmv_read_line(L),
      format_debug(6, "header line: ~w", [L]),
      nusmv_read_header
   ;
      (
         C1 = '\n'
      ;
         C1 = '\r'
      )
   ->
         format_debug(6, "empty header line", []),
         get_char(nusmv_out, C1),
         nusmv_read_header
      ;
         format_debug(6, "no header~n", []),
         nusmv_read_prompt
   ).

% Reads _up to_ the next prompt

nusmv_read_prompt:-
   format_debug(5,"Reading prompt~n",[]),
   repeat,
      peek_char(nusmv_out,C),
      format_debug(5,"~w",[C]),
      get_char(nusmv_out,'N'),
      get_char(nusmv_out,'u'),
      get_char(nusmv_out,'S'),
      get_char(nusmv_out,'M'),
      get_char(nusmv_out,'V'),
      get_char(nusmv_out,' '),
      get_char(nusmv_out,'>'),
      get_char(nusmv_out,' '),!.




%  Specification CTL
add_specs((Query,L)):-
   !,add_spec(Query),
   add_specs(L).
add_specs(Query):-
   add_spec(Query).
add_spec(Q):-
   parse_query(Q,Query), % FF added for normalization
   (
      have_gui
   ->
      format("[GUI] add_spec ~w~n",[Q])
   ;
      true
   ),
	classifies_formula(Query,C),
	(
      silence_mode
   ->
      true
   ;
      format_debug(1,"Specification as ~w formula added : ~w~n",[C,Query])
   ),
	assertset(spec(Query,C,_)),
	!.

%positive_and_negative
classifies_formula(Query,C):-
	(
	  classification_formula(Query,C)
	->
	  true
	;
	  C='undefined'
	).

classification_formula(Q1 & Q2,C):-
	!,
	classification_formula(Q1,C),
	classification_formula(Q2,C).
classification_formula('|'(Q1, Q2),C):-
	!,
	classification_formula(Q1,C),
	classification_formula(Q2,C).
classification_formula(Q1 -> Q2,C):-% !Q1 | Q2
	!,
	classification_formula(!(Q1),C),
	classification_formula(Q2,C).

classification_formula(Q1 <-> Q2,C):- % (Q1&Q2) | (!Q1&!Q2) 
	!, 
	classification_formula(Q1,C),
	classification_formula(Q2,C),
	classification_formula(!(Q1),C), % FF semble inutile ?
	classification_formula(!(Q2),C).



classification_formula(!(Q),C):-
	!,
	(
	  var(C)
	->
	  D=C  % FF semble faux pour formules complexes ???
	;
	  (
	    (C='negative')
	  ->
	    (D='positive')
	  ;
	    (
	      (C='positive')
	    ->
	      (D='negative')
	    ;
	      fail		% C='undefined'
	    )
	  )
	),
	classification_formula(Q,D).

classification_formula(!(Q),C):-
	!,C='positive',
	classification_formula(Q,'negative').
classification_formula(!(Q),C):-
	!,C='negative',
	classification_formula(Q,'positive').



classification_formula('Ei'(Q),C):-
	!,C='positive',
	classification_formula(Q,'positive').
classification_formula('EX'(Q),C):-
	!,C='positive',
	classification_formula(Q,'positive').
classification_formula('EF'(Q),C):-
	!,C='positive',
	classification_formula(Q,'positive').
classification_formula('EG'(Q),C):-
	!,C='positive',
	classification_formula(Q,'positive').
classification_formula('E'((Q1)'U'(Q2)),C):-
	!,C='positive',
	classification_formula(Q1,'positive'),
	classification_formula(Q2,'positive').
%classification_formula('E'((Q1)'W'(Q2)),C):-
%	!,C='positive',
%	classification_formula(Q1,'positive'),
%	classification_formula(Q2,'positive').

classification_formula('Ai'(Q),C):-
	!,C='negative',
	classification_formula(Q,'negative').
classification_formula('AX'(Q),C):-
	!,C='negative',
	classification_formula(Q,'negative').
classification_formula('AF'(Q),C):-
	!,C='negative',
	classification_formula(Q,'negative').
classification_formula('AG'(Q),C):-
	!,C='negative',
	classification_formula(Q,'negative').
%classification_formula('A'(Q1)'W'(Q2),'negative'):-
%	!,
%	classification_formula(Q1,'negative'),
%	classification_formula(Q2,'negative').

classification_formula(checkpoint(Q1,Q2),C):- 
	!,C='negative',
	classification_formula(Q1,'positive'),
	classification_formula(Q2,'positive').
classification_formula(reachable(Q),C):-
	!,C='positive',
	classification_formula(Q,'positive').
classification_formula(steady(Q),C):-
	!,C='positive',
	classification_formula(Q,'positive').
classification_formula(stable(Q),C):-
	!,C='negative',
	classification_formula(Q,'negative').
classification_formula(oscil(_),_):-
	!,fail.
classification_formula(loop(_,_),_):-
	!,fail.

classification_formula(Q,_):- % can be positive or negative formula
	catch(is_object(Q),_,fail),   % Sylvain : we do NOT want an exception if
                                 % this fails !!!
	!.
classification_formula(_,'undefined'):-!.





delete_specs((Q,L)):-
   !,
   delete_spec(Q),
   delete_specs(L).
delete_specs(Q):-
   delete_spec(Q).

delete_spec(Query):-
   retractall(spec(Query,_,_)).

list_spec:-
   writeall(spec(Q,_,_),Q).

clear_spec:-
   retractall(spec(_,_,_)).






% parses, checks and translates a query, then send it through the pipe to
% NuSMV

check_ctl(Q):-nusmv(Q).
check_why(Q):-nusmv_why(Q).

nusmv(Query):-
   parse_query(Query,Q), % FF added for normalization
   (
      learning_mode
   ->
      true  % do not measure time in learning mode
   ;
      nusmv_time(_)
   ),
   check_init,
   %write('Gene compounds not explicitely present will be added\n'),
   %write('   to the ABSENT list of the initial state\n\n'),
   complete_init,
   (
      (
	nusmv_running,
	!,
	nusmv_load
      )
   ;
      launch
   ),
   (
      learning_mode
   ->
      true
   ;
     (
       nusmv_time(T1),
      
        (
                have_gui
        ->
                format("[GUI] checkCTL Loading time: ~2f s~n",[T1])
        ;
       format("Loading time: ~2f s~n",[T1])
     )
     )
   ),
   retractall(last_query(_,_,_)),
   nusmv_translate(Q,Q1),   % converts w.r.t. the fake initial state
   format_debug(3,"after converting the fake initial state \"~w\"~n",[Q1]),
   nusmv_translate_query(Q1,Q2),
   format_debug(3,"sending \"~w\" to NuSMV~n",[Q2]),
   nusmv_requete(Q2,Rep),
   (
      learning_mode
   ->
      true
   ;
      
        (
                have_gui
        ->
                format("[GUI] checkCTL ~w is ~w~n",[Q,Rep])
        ;
                format("~n~w is ~w~n",[Q,Rep])
        ),
      nusmv_time(T2),
      
        (
                have_gui
        ->
                format("[GUI] checkCTL Query time: ~2f s~n",[T2])
        ;
      format("Query time: ~2f s~n",[T2])
        )
   ),
   assertz(last_query(Q,Q2,Rep)),	% query
   !.			
% Timing (use real_time if less than 2secs, otherwise use date_time since
% NuSMV runs as another process...

nusmv_time(T):-
   date_time(dt(_,_,_,H,M,S)),
   S2 is 3600*H + 60*M + S,
   g_read(nusmv_s,S1),
   g_assign(nusmv_s,S2),
   statistics(real_time,[_,MS]),
   g_assign(nusmv_ms,MS),
   T1 is S2 - S1 mod 86400,   % FIXME max is 1 day
   (
      (T1 > 2)
   ->
      (T=T1)
   ;
      % if less than 2 secs, don't use date_time
      (T is MS / 1000)
   ),
   !.

%
nusmv_dynamic_reordering:-nusmv_dynamic_reordering('group_sift_converge').
nusmv_dynamic_reordering(M):-
	retractall(dynamic_order_method(_)),
	assertz(dynamic_order_method(M)),
	nusmv_running,
	format(nusmv_in,"dynamic_var_ordering -e ~w ~n",[M]),
	flush_output(nusmv_in),
	nusmv_read_line(L),
	L=['D','y','n','a','m','i','c'|_],
	nusmv_read_prompt.
nusmv_disable_dynamic_reordering:-
	retractall(dynamic_order_method(_)),	
	nusmv_running,
	format(nusmv_in,"dynamic_var_ordering -d~n",[]),
	flush_output(nusmv_in),
	nusmv_read_line(L),
	L=['D','y','n','a','m','i','c'|_],
	nusmv_read_prompt.

nusmv_err_out_put:-
	smv_file_out_err(OEN),
	format(nusmv_in,"set nusmv_stderr ~w~n",[OEN]),
	flush_output(nusmv_in),
	nusmv_read_prompt,!.


%nusmv_err_out_put:-
%%	g_read(debug,L),
%%	L>4,
%	g_read(compteur_sortie_err,N),
%	Np is N+1,
%	g_assign(compteur_sortie_err,Np),
%	format("write for nusmv: set nusmv_stderr  sortie_err_nusmv~w~n",[N]),
%	format(nusmv_in,"set nusmv_stderr  sortie_err_nusmv~w~n",[N]),
%	nusmv_read_prompt,!.
%nusmv_err_out_put:-
%	g_read(compteur_sortie_err,N),
%	Np is N+1,
%	g_assign(compteur_sortie_err,Np),
%	format("DONT write for nusmv: set nusmv_stderr  sortie_err_nusmv~w~n",[N]).


% Send the query

nusmv_requete(Q,R):-
   format_debug(4,"write for nusmv: check_ctlspec -p \"~w\"~n",[Q]),
   format(nusmv_in,"check_ctlspec -p \"~w\"~n",[Q]), 
   flush_output(nusmv_in),
   nusmv_read_answer(R).

% parse the answer
% .... is true/false
% and parse a trace if one is given
nusmv_read_answer(R):-
   format_debug(5,"Reading answer~n",[]),
   (
      repeat,
      get_spaces(nusmv_out),
      get_char(nusmv_out,'i'),
      get_char(nusmv_out,'s'),
      get_char(nusmv_out,' '),
      !
   ),
   read_atom(nusmv_out,R),
   % FIXME NuSMV 2.5.3 gets prompt in the middle of the answer line...
   %nusmv_read_line(R),
   format_debug(5,"Read: ~w~n",[R]),
   get_char(nusmv_out, '\n'),
   peek_char(nusmv_out, A),
   format_debug(5,"~w",[A]),
   (
      (A = (-))
   ->
      retractall(nusmv_path(_,_)),
      g_assign(nusmv_state,0),
      nusmv_read_trace
    % ,( learning_mode -> true ; show_path) le show_path est effectu� maintenant dans le why
   ;
      nusmv_read_prompt
   ),!.  % FIXME dunno why this cut is necessary, but it is!!! % peut-�tre parce que read-trace backtrack (et plante)

get_spaces(S):-
   peek_char(S,C),
   (
      (C = ' ')
   ->
      get_char(S, C),
      get_spaces(S)
   ;
      true
   ),!.

% force NuSMV to send a trace

why:- 
   last_query(_,Q2,Rep),!,
   format_debug(4,"write for nusmv set counter_examples 1~n",[]),
   write(nusmv_in,'set counter_examples 1\n'),
   nusmv_read_prompt,
   (
      (Rep='true') 
   ->
      nusmv_negation_query(Q2,Q3)
   ;
      (Q3=Q2)
   ),
   (learning_mode   ->     true   ; nusmv_time(_)),
   nusmv_requete(Q3,_),
   show_path, % silencieux pour le learning_mode
   (
     learning_mode
   ->
     true
   ;
     (
       nusmv_time(T),
       
        (
                have_gui
        ->
                format("[GUI] checkCTL Query time: ~2f s~n",[T])
        ;
       format("Query time: ~2f s~n",[T])
     )
     )
   ),
   format_debug(4,"write for nusmv set counter_examples 0~n",[]),
   write(nusmv_in,'set counter_examples 0\n'),
   nusmv_read_prompt,
   !.

why:- (
                have_gui
        ->
                format("[GUI] warnings Ask a CTL query before using ''why'' (use nusmv(Query)).~n",[])
        ;
                write('Ask a CTL query before using ''why'' (use nusmv(Query))'),nl
        ).


nusmv_why(Q):-
   format_debug(4,"write for nusmv set counter_examples 1~n",[]),
   write(nusmv_in,'set counter_examples 1\n'),
   nusmv_read_prompt,
   nusmv(Q),
   format_debug(4,"write for nusmv set counter_examples 0~n",[]),
   write(nusmv_in,'set counter_examples 0\n'),
   nusmv_read_prompt,
   last_query(Q,_,Rep),
   (
     (Rep='true') 
   ->
     why
     ;
     show_path
   ),!.

%check:-
%	retract(spec(Q,C,_)),
%	nusmv(Q),
%	last_query(Q,_,A),
%	assertz(spec(Q,C,A)),
%	C='negative',
%	retractall(pathway(Q,_)),
%	 (
%	   (%learning_mode,
%	       A=false)
%	 ->
%	   (
%	     why,
%	     findall(R,last_path(R),Path),
%	     assertset(pathway(Q,Path))
%	   )
%	 ;
%	   true
%	 ),
%	 fail.
%check:-!.

check_spec:- check.

check:-check(_,_).
check(C):-check(C,_).
check(C,A):-
	retract(spec(Q,C,A)),
	nusmv(Q),
	last_query(Q,_,Ap),
	assertz(spec(Q,C,Ap)),
	C='negative',
	retractall(pathway(Q,_)),
	 (
	   (%learning_mode,
	       Ap=false)
	 ->
	   (
	     why,
	  %   findall(R,last_path(R),Path),
	     findall(R,(last_path(NR),rule(NR,R)),Path),
	     assertset(pathway(Q,Path))
	   )
	 ;
	   true
	 ),
	 fail.
check(_,_):-!.


check_why_spec:-check_why.

check_why:-
	spec(Q,_,_),
	nusmv_why(Q),
	fail.
check_why:-!.

test_all:-test_all(_,_).
test_all(C):-test_all(C,_).
test_all(C,A):-
	assertz(learning_mode),
	spec(Q,C,A),
	nusmv(Q),
	last_query(_,_,false),
	(
	  score_mode
	->
	  (
	    g_read(nb_Q_a_retraite,N),
	    Np is N+1,
	    g_assign(nb_Q_a_retraite,Np),
	    g_read(q_a_retraite,Lq),
	    g_assign(q_a_retraite,[(Q,C)|Lq]),
	    fail
	  )
	;
	  true
	),  
	retract(learning_mode),!.  % le cut est pour ne pas backtracker sur le retract

test_all(_,_):-
	retract(learning_mode),!. % le cut est pour ne pas backtracker sur le retract

check_all_spec:-check_all.

check_all:-
   retractall(last_query(_,_,_)),
   nusmv_time(_),
   test_all,
   last_query(Q,_,false),
   (
      have_gui
   ->
      format("[GUI] checkCTL The specification is not satisfied.~n~nThis formula is the first not verified: ~w ~n",[Q])
   ;
      format("The specification is not satisfied.~nThis formula is the first not verified: ~w ~n",[Q])
   ),
   nusmv_time(T),
   (
      have_gui
   ->
      format("[GUI] checkCTL Loading and Querying time: ~2f s~n",[T])
   ;
      format("Loading and Querying time: ~2f s~n",[T])
   ),
   retractall(learning_mode),
   !.
check_all:-
   (
      have_gui
   ->
      format("[GUI] checkCTL The specification is satisfied, all formulae are verified ~n",[])
   ;
      format("The specification is satisfied, all formulae are verified ~n",[])
   ),
   nusmv_time(T),
   (
      have_gui
   ->
      format("[GUI] checkCTL Loading and Querying time: ~2f s~n",[T])
   ;
      format("Loading and Querying time: ~2f s~n",[T])
   ),
   retractall(learning_mode),
   !.
% Read lines starting with '-' or ' ' (otherwise we're done -> prompt)
% if one of them is '   R = number' store the number

nusmv_read_trace:-
   peek_char(nusmv_out,C),
   format_debug(5,"Reading trace~n",[]),
   format_debug(5,"~w",[C]),
   (
      (C='N')
   ->
      nusmv_read_prompt
   ;
      get_char(nusmv_out,C),
      nusmv_read_line(L),
      g_read(nusmv_state,NS),
      (
         (L = ['>',' ','S','t','a','t','e'|_])
      ->
         (
            M is NS+1,
            g_assign(nusmv_state,M),
            (
               (NS = 0)
            ->
               assertz(nusmv_path(rule(1),0))      % rule for initial state
            ;
               (                                   % for other cases,
                  nusmv_path(rule(NS),RN),         % get previous one
                  assertz(nusmv_path(rule(M),RN))  % and copy it
               )
            )
         )
      ;
         (
            (L = ['-',' ','L','o','o','p'|_])
         ->
            assertz(nusmv_path(loop,start))
         ;
            (
               (
                  L = [' ',' ',' ','R',' ','=',' '|LL]   % NuSMV 2.1.2
               ;
                  L = [' ','R',' ','=',' '|LL]           % NuSMV 2.2.2
               )
            ->
               (
                  (
                     nusmv_fairness_path
                  ->
                     (
                        append(['_'|LnumR],LLend,LL),
                        (LLend=['_'|_]; LLend=['\n']),
                        \+(memberchk('_',LnumR)),
                        format_to_atom(B,"~S",[LnumR])
                     )
                  ;
                     (
                        format_to_atom(A,"~S",[LL]),
                        atom_concat(B,'\n',A)
                     )
                  ),
                  number_atom(N,B),
                  retractall(nusmv_path(rule(NS),_)),
                  assertz(nusmv_path(rule(NS),N))
               )
            ;
               (
                  (% same as above
                     L = [' ',' ',' '|LL]
                  ;
                     L = [' '|LL]
                  )
               ->
                  (
                     (
                        append(L1, [' ', '=', ' ', '0', '\n'], LL)
                     ;
                        append(L1,
                           [' ', '=', ' ', 'F', 'A', 'L', 'S', 'E', '\n'], LL)
                     )
                  ->
                     (State = 'absent')
                  ;
                     (
                        append(L1, [' ', '=', ' ', '1', '\n'], LL)
                     ;
                        append(L1,
                           [' ', '=', ' ', 'T', 'R', 'U', 'E', '\n'], LL)
                     ),
                     (State = 'present')
                  ),
                     nusmv_read_molecule(L1,A),
                     assertz(nusmv_path(State,A))
                  ;
                     true
               )
            )
         )
   ),
   nusmv_read_trace
),
   !.
   
% read a full line and make it a char list
nusmv_read_line(L):-
   retractall(nusmv_line(_)),
   (
      repeat,
      get_char(nusmv_out,C),
      format_debug(5,"~w",[C]),
      assertz(nusmv_line(C)),
      (C='\n'),
      !
   ),
   findall(A,nusmv_line(A),L).


% read a full line and make it a char list
%FIXME not used
nusmv_read_line_err(L):-
   retractall(nusmv_line(_)),
   repeat,
      get_char(nusmv_out_err,C),
      format_debug(5,"~w",[C]),
      assertz(nusmv_line(C)),
      (C='\n'),!,
   findall(A,nusmv_line(A),L).


% Show pathway AND state changes plus loops

show_path:-
   (nusmv_path(rule(2),_); no_false_initial_state),!,   % We have a real pathway
   retractall(last_path(_)),
   repeat,
      retract(nusmv_path(A,B)),
      (
         ((A,B) = (loop,start))
      ->
	(
	   learning_mode
	 ->
	   ( true )
	 ;
	   ( write('-- Loop starts here\n')  )
	 )
      ;
         true
      ),
   (
     no_false_initial_state
   ->
     ((A = rule(1)),!)
   ;
     ((A = rule(2)),!)
   ),
   g_assign(nusmv_cur_rule,B),
   findall((C,D),nusmv_path(C,D),L),
   show_path_rec(L).

show_path:-
   nusmv_path(rule(1),_),!,   % Initial state only
   retractall(last_path(_)),
   (
     learning_mode
   ->
     ( true )
   ;
     (write('Initial state\n') )
   ).

show_path:-
   retractall(last_path(_)).

show_path_rec([(rule(_),I),(rule(N),J)|L]):-
   g_assign(nusmv_cur_rule,I),
   show_path_rec([(rule(N),J)|L]).
   
show_path_rec([(A,B)|L]):-
   g_read(nusmv_cur_rule,CR),
   write_path(A,B,CR),
   show_path_rec(L).

show_path_rec([]).
   
write_path(rule(_),B,CR):-
    (learning_mode -> true ;pathway([CR])),
   assertz(last_path(CR)),
   g_assign(nusmv_cur_rule,B).

write_path(present,B,_):-
   (learning_mode -> true ;format("   ~w is present~n",[B])),
        (
                have_gui
        ->
                format("[GUI] checkCTL ~w is present~n",[B])
        ;
                true
        ).

write_path(absent,B,_):-
   (learning_mode -> true ; format("   ~w is absent~n",[B])),
        (
                have_gui
        ->
                format("[GUI] checkCTL ~w is absent~n",[B])
        ;
                true
        ).

write_path(loop,start,_):-
   (learning_mode -> true ; write('-- Loop starts here\n')).

% if no pathway given, use the latest one provided by NuSMV

pathway:-
   findall(R,last_path(R),L),
   pathway(L).

% shortcuts for common queries

check_reachable(S) :-
   nusmv('Ei'('EF'(S))).

check_stable(S) :-
   nusmv('Ai'('AG'(S))).

check_steady(S) :-
   nusmv('Ei'('EG'(S))).

check_checkpoint(C,S) :-
   nusmv('Ai'('!'('E'('U'('!'(C),S))))).

check_loop(S1,S2) :-
   nusmv('Ai'('AG'('&'('->'(S1,'EF'(S2)),'->'(S2,'EF'(S1)))))).

check_oscil(S):-
   check_loop(S,'!'(S)).

% Read a list of chars and translate NuSMV notations to a BIOCHAM molecule

nusmv_read_molecule(L,M):-
   nusmv_ununderscore(L,L1),
   remove_empty_quotes([''''|L1],L2),
   read_from_chars(L2,M).

nusmv_ununderscore(['_','z'|L],['''',':',':',''''|L1]):-
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore(['_','L'|L],['''','(',''''|L1]):-
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore(['_','_'|L],['R'|L1]):-
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore(['_','R'|L],['''',')',''''|L1]):-
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore(['_','l'|L],['''','~','{',''''|L1]):-
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore(['_','r'|L],['''','}',''''|L1]):-
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore(['_','c'|L],['''',',',''''|L1]):-
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore(['_', ('$') | L],['''','@',''''|L1]):-
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore(['_', ('#') | L],['''','#',''''|L1]):-
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore(['_',X|L],[X|L1]):-
   is_reserved(X),
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore(['_','x','o','r'|L],['x','o','r'|L1]):-
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore([('-') | L],['''','-',' ',''''|L1]):-
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore([H|L],[H|L1]):-
   !,nusmv_ununderscore(L,L1).

nusmv_ununderscore([],['''','.']).

is_reserved('B').
is_reserved('F').
is_reserved('G').
is_reserved('H').
is_reserved('O').
is_reserved('S').
is_reserved('T').
is_reserved('V').
is_reserved('W').
is_reserved('X').
is_reserved('Y').
is_reserved('Z').
is_reserved('R').
is_reserved('_').
is_reserved('B').
is_reserved('A').
is_reserved('E').
is_reserved('U').

% Avoid too many quotes

remove_empty_quotes(['''',''''|L1],L2):-
   !,remove_empty_quotes(L1,L2).

remove_empty_quotes([H|L1],[H|L2]):-
   remove_empty_quotes(L1,L2).

remove_empty_quotes([],[]).
